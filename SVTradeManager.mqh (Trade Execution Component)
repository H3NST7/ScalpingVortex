//+------------------------------------------------------------------+
//|                                              SVTradeManager.mqh   |
//+------------------------------------------------------------------+
#property copyright "ScalpingVortex"
#property link      "https://github.com/H3NST7/ScalpingVortex"
#property version   "1.00"
#property strict

// Include required files
#include "ScalpingVortex\SVUtils.mqh"
#include "ScalpingVortex\SVPortfolio.mqh"

//+------------------------------------------------------------------+
//| Trade Manager class for order execution and management            |
//+------------------------------------------------------------------+
class CSVTradeManager
{
private:
   // References to other components
   CSVPortfolio*      m_portfolio;
   
   // Trade parameters
   int               m_magicNumber;
   int               m_slippage;
   string            m_tradeComment;
   bool              m_isInitialized;
   datetime          m_lastUpdateTime;
   
   // Risk management parameters
   double            m_riskPerTrade;  // Risk percentage per trade
   int               m_maxOpenPositions; // Maximum number of open positions
   
   // Internal statistics
   int               m_ordersOpened;
   int               m_ordersClosed;
   int               m_ordersModified;
   
   // Tracking pending order execution
   int               m_lastTicket;
   bool              m_pendingOrderExecution;
   
public:
                     CSVTradeManager();
                     ~CSVTradeManager();
   
   // Initialization and update methods
   bool              Initialize(CSVPortfolio* portfolio, int magicNumber, int slippage);
   bool              Update();
   
   // Risk management
   void              SetRiskPerTrade(double riskPercent) { m_riskPerTrade = riskPercent; }
   double            GetRiskPerTrade() const { return m_riskPerTrade; }
   
   void              SetMaxOpenPositions(int max) { m_maxOpenPositions = max; }
   int               GetMaxOpenPositions() const { return m_maxOpenPositions; }
   
   // Order execution methods
   bool              OpenBuyOrder(string symbol, double lotSize, double stopLoss, double takeProfit);
   bool              OpenSellOrder(string symbol, double lotSize, double stopLoss, double takeProfit);
   bool              OpenBuyLimit(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit);
   bool              OpenSellLimit(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit);
   bool              OpenBuyStop(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit);
   bool              OpenSellStop(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit);
   
   // Order management methods
   bool              ModifyOrder(int ticket, double stopLoss, double takeProfit);
   bool              CloseOrder(int ticket, double lots = 0.0);
   bool              CloseAllOrders();
   bool              DeletePendingOrder(int ticket);
   bool              DeleteAllPendingOrders();
   
   // Status methods
   bool              IsInitialized() const { return m_isInitialized; }
   int               GetLastTicket() const { return m_lastTicket; }
   bool              HasPendingExecution() const { return m_pendingOrderExecution; }
   
   // Order information methods
   bool              GetOrderDetails(int ticket, int &type, double &openPrice, double &lots, 
                                    double &stopLoss, double &takeProfit);
   
private:
   // Helper methods
   bool              ValidateTradeParameters(string symbol, double lotSize, double stopLoss, double takeProfit);
   bool              IsOrderStillValid(int ticket);
};

//+------------------------------------------------------------------+
//| Constructor                                                      |
//+------------------------------------------------------------------+
CSVTradeManager::CSVTradeManager()
{
   m_portfolio = NULL;
   m_magicNumber = 12345; // Default magic number
   m_slippage = 3;        // Default slippage
   
   m_tradeComment = "ScalpingVortex";
   m_isInitialized = false;
   m_lastUpdateTime = 0;
   
   m_riskPerTrade = 1.0;   // Default risk 1% per trade
   m_maxOpenPositions = 5; // Default max 5 open positions
   
   m_ordersOpened = 0;
   m_ordersClosed = 0;
   m_ordersModified = 0;
   
   m_lastTicket = 0;
   m_pendingOrderExecution = false;
}

//+------------------------------------------------------------------+
//| Destructor                                                       |
//+------------------------------------------------------------------+
CSVTradeManager::~CSVTradeManager()
{
   // We don't delete m_portfolio because it's owned elsewhere
}

//+------------------------------------------------------------------+
//| Initialize the trade manager                                     |
//+------------------------------------------------------------------+
bool CSVTradeManager::Initialize(CSVPortfolio* portfolio, int magicNumber, int slippage)
{
   if(portfolio == NULL)
      return false;
      
   m_portfolio = portfolio;
   m_magicNumber = magicNumber;
   m_slippage = slippage;
   
   m_lastUpdateTime = TimeCurrent();
   m_isInitialized = true;
   
   return true;
}

//+------------------------------------------------------------------+
//| Update method - called on each tick                              |
//+------------------------------------------------------------------+
bool CSVTradeManager::Update()
{
   if(!m_isInitialized)
      return false;
      
   // Check for day change to reset daily stats
   datetime currentTime = TimeCurrent();
   MqlDateTime dtCurrent, dtLast;
   TimeToStruct(currentTime, dtCurrent);
   TimeToStruct(m_lastUpdateTime, dtLast);
   
   if(dtCurrent.day != dtLast.day || dtCurrent.mon != dtLast.mon)
   {
      // Reset daily stats here if needed
   }
   
   m_lastUpdateTime = currentTime;
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a new buy order                                             |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenBuyOrder(string symbol, double lotSize, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Check if we haven't exceeded maximum open positions
   int openPositions = 0;
   if(m_portfolio != NULL)
   {
      openPositions = m_portfolio.CountOpenPositions();
      if(openPositions >= m_maxOpenPositions)
      {
         Print("Maximum number of open positions reached: ", m_maxOpenPositions);
         return false;
      }
   }
   
   // Calculate entry price
   double price = MarketInfo(symbol, MODE_ASK);
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (price - stopLoss) < stopsLevel * point)
   {
      stopLoss = price - stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (takeProfit - price) < stopsLevel * point)
   {
      takeProfit = price + stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the order
   int ticket = OrderSend(symbol, OP_BUY, lotSize, price, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening BUY order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("BUY order opened successfully. Ticket: ", ticket, ", Price: ", price, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a new sell order                                            |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenSellOrder(string symbol, double lotSize, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Check if we haven't exceeded maximum open positions
   int openPositions = 0;
   if(m_portfolio != NULL)
   {
      openPositions = m_portfolio.CountOpenPositions();
      if(openPositions >= m_maxOpenPositions)
      {
         Print("Maximum number of open positions reached: ", m_maxOpenPositions);
         return false;
      }
   }
   
   // Calculate entry price
   double price = MarketInfo(symbol, MODE_BID);
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (stopLoss - price) < stopsLevel * point)
   {
      stopLoss = price + stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (price - takeProfit) < stopsLevel * point)
   {
      takeProfit = price - stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the order
   int ticket = OrderSend(symbol, OP_SELL, lotSize, price, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening SELL order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("SELL order opened successfully. Ticket: ", ticket, ", Price: ", price, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a buy limit order                                           |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenBuyLimit(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Validate limit order price (must be below market price)
   double marketPrice = MarketInfo(symbol, MODE_ASK);
   if(entryPrice >= marketPrice)
   {
      Print("Buy limit price must be below current market price. Market: ", marketPrice, ", Entry: ", entryPrice);
      return false;
   }
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (entryPrice - stopLoss) < stopsLevel * point)
   {
      stopLoss = entryPrice - stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (takeProfit - entryPrice) < stopsLevel * point)
   {
      takeProfit = entryPrice + stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the limit order
   int ticket = OrderSend(symbol, OP_BUYLIMIT, lotSize, entryPrice, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening BUY LIMIT order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("BUY LIMIT order placed successfully. Ticket: ", ticket, ", Entry Price: ", entryPrice, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a sell limit order                                          |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenSellLimit(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Validate limit order price (must be above market price)
   double marketPrice = MarketInfo(symbol, MODE_BID);
   if(entryPrice <= marketPrice)
   {
      Print("Sell limit price must be above current market price. Market: ", marketPrice, ", Entry: ", entryPrice);
      return false;
   }
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (stopLoss - entryPrice) < stopsLevel * point)
   {
      stopLoss = entryPrice + stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (entryPrice - takeProfit) < stopsLevel * point)
   {
      takeProfit = entryPrice - stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the limit order
   int ticket = OrderSend(symbol, OP_SELLLIMIT, lotSize, entryPrice, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening SELL LIMIT order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("SELL LIMIT order placed successfully. Ticket: ", ticket, ", Entry Price: ", entryPrice, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a buy stop order                                            |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenBuyStop(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Validate stop order price (must be above market price)
   double marketPrice = MarketInfo(symbol, MODE_ASK);
   if(entryPrice <= marketPrice)
   {
      Print("Buy stop price must be above current market price. Market: ", marketPrice, ", Entry: ", entryPrice);
      return false;
   }
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (entryPrice - stopLoss) < stopsLevel * point)
   {
      stopLoss = entryPrice - stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (takeProfit - entryPrice) < stopsLevel * point)
   {
      takeProfit = entryPrice + stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the stop order
   int ticket = OrderSend(symbol, OP_BUYSTOP, lotSize, entryPrice, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening BUY STOP order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("BUY STOP order placed successfully. Ticket: ", ticket, ", Entry Price: ", entryPrice, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Open a sell stop order                                           |
//+------------------------------------------------------------------+
bool CSVTradeManager::OpenSellStop(string symbol, double lotSize, double entryPrice, double stopLoss, double takeProfit)
{
   if(!m_isInitialized)
      return false;
      
   // Validate parameters
   if(!ValidateTradeParameters(symbol, lotSize, stopLoss, takeProfit))
      return false;
      
   // Validate stop order price (must be below market price)
   double marketPrice = MarketInfo(symbol, MODE_BID);
   if(entryPrice >= marketPrice)
   {
      Print("Sell stop price must be below current market price. Market: ", marketPrice, ", Entry: ", entryPrice);
      return false;
   }
   
   // Validate stop loss and take profit
   double point = MarketInfo(symbol, MODE_POINT);
   int stopsLevel = (int)MarketInfo(symbol, MODE_STOPLEVEL);
   
   if(stopLoss > 0 && (stopLoss - entryPrice) < stopsLevel * point)
   {
      stopLoss = entryPrice + stopsLevel * point;
      Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
   }
      
   if(takeProfit > 0 && (entryPrice - takeProfit) < stopsLevel * point)
   {
      takeProfit = entryPrice - stopsLevel * point;
      Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
   }
   
   // Set flags for order execution tracking
   m_pendingOrderExecution = true;
   
   // Open the stop order
   int ticket = OrderSend(symbol, OP_SELLSTOP, lotSize, entryPrice, m_slippage, stopLoss, takeProfit, m_tradeComment, m_magicNumber);
   
   if(ticket <= 0)
   {
      int errorCode = GetLastError();
      Print("Error opening SELL STOP order: ", errorCode, " - ", GetErrorDescription(errorCode));
      m_pendingOrderExecution = false;
      return false;
   }
   
   // Update tracking
   m_lastTicket = ticket;
   m_ordersOpened++;
   m_pendingOrderExecution = false;
   
   Print("SELL STOP order placed successfully. Ticket: ", ticket, ", Entry Price: ", entryPrice, ", Lots: ", lotSize);
   
   return true;
}

//+------------------------------------------------------------------+
//| Modify an existing order                                         |
//+------------------------------------------------------------------+
bool CSVTradeManager::ModifyOrder(int ticket, double stopLoss, double takeProfit)
{
   if(!m_isInitialized || ticket <= 0)
      return false;
      
   // Select the order
   if(!OrderSelect(ticket, SELECT_BY_TICKET))
   {
      int errorCode = GetLastError();
      Print("Error selecting order #", ticket, " for modification: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Check if the order belongs to our EA
   if(OrderMagicNumber() != m_magicNumber)
   {
      Print("Cannot modify order #", ticket, " - it does not belong to this EA.");
      return false;
   }
      
   // Check if the order is still open
   if(OrderCloseTime() > 0)
   {
      Print("Cannot modify order #", ticket, " - it is already closed.");
      return false;
   }
      
   // Get the current stop loss and take profit
   double currentSL = OrderStopLoss();
   double currentTP = OrderTakeProfit();
   
   // Check if modification is needed
   if(MathAbs(currentSL - stopLoss) < 0.00001 && MathAbs(currentTP - takeProfit) < 0.00001)
   {
      Print("No modification needed for order #", ticket);
      return true; // No modification needed
   }
      
   // Validate stop loss and take profit based on order type
   int orderType = OrderType();
   double openPrice = OrderOpenPrice();
   double point = MarketInfo(OrderSymbol(), MODE_POINT);
   int stopsLevel = (int)MarketInfo(OrderSymbol(), MODE_STOPLEVEL);
   
   // Adjust stop loss and take profit for market distance requirements
   if(orderType == OP_BUY || orderType == OP_BUYLIMIT || orderType == OP_BUYSTOP)
   {
      // For buy orders, SL must be below, TP must be above
      if(stopLoss > 0 && (openPrice - stopLoss) < stopsLevel * point)
      {
         stopLoss = openPrice - stopsLevel * point;
         Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
      }
         
      if(takeProfit > 0 && (takeProfit - openPrice) < stopsLevel * point)
      {
         takeProfit = openPrice + stopsLevel * point;
         Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
      }
   }
   else if(orderType == OP_SELL || orderType == OP_SELLLIMIT || orderType == OP_SELLSTOP)
   {
      // For sell orders, SL must be above, TP must be below
      if(stopLoss > 0 && (stopLoss - openPrice) < stopsLevel * point)
      {
         stopLoss = openPrice + stopsLevel * point;
         Print("Stop Loss adjusted to meet minimum distance requirement: ", stopLoss);
      }
         
      if(takeProfit > 0 && (openPrice - takeProfit) < stopsLevel * point)
      {
         takeProfit = openPrice - stopsLevel * point;
         Print("Take Profit adjusted to meet minimum distance requirement: ", takeProfit);
      }
   }
   
   // Modify the order
   bool result = OrderModify(ticket, openPrice, stopLoss, takeProfit, 0);
   
   if(!result)
   {
      int errorCode = GetLastError();
      Print("Error modifying order #", ticket, ": ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   m_ordersModified++;
   Print("Order #", ticket, " modified successfully. New SL: ", stopLoss, ", New TP: ", takeProfit);
   
   return true;
}

//+------------------------------------------------------------------+
//| Close a specific order                                           |
//+------------------------------------------------------------------+
bool CSVTradeManager::CloseOrder(int ticket, double lots = 0.0)
{
   if(!m_isInitialized || ticket <= 0)
      return false;
      
   // Select the order
   if(!OrderSelect(ticket, SELECT_BY_TICKET))
   {
      int errorCode = GetLastError();
      Print("Error selecting order #", ticket, " for closing: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Check if the order belongs to our EA
   if(OrderMagicNumber() != m_magicNumber)
   {
      Print("Cannot close order #", ticket, " - it does not belong to this EA.");
      return false;
   }
      
   // Check if the order is still open
   if(OrderCloseTime() > 0)
   {
      Print("Order #", ticket, " is already closed.");
      return true;
   }
      
   // Get order details
   int orderType = OrderType();
   double orderLots = OrderLots();
   
   // For pending orders, use Delete instead of Close
   if(orderType > OP_SELL)
   {
      return DeletePendingOrder(ticket);
   }
   
   // If partial close is requested, validate the lot size
   if(lots > 0 && lots < orderLots)
   {
      // Adjust the lots if needed
      double minLot = MarketInfo(OrderSymbol(), MODE_MINLOT);
      double lotStep = MarketInfo(OrderSymbol(), MODE_LOTSTEP);
      
      // Ensure the lot size is valid
      lots = NormalizeDouble(MathFloor(lots / lotStep) * lotStep, 2);
      
      if(lots < minLot)
      {
         Print("Cannot close ", lots, " lots - less than minimum lot size (", minLot, ")");
         return false;
      }
      
      if(orderLots - lots < minLot)
      {
         Print("Remaining lots would be less than minimum. Closing entire position.");
         lots = orderLots;
      }
   }
   else
   {
      // Close the entire position
      lots = orderLots;
   }
   
   // Get closing price based on order type
   double closePrice;
   
   if(orderType == OP_BUY)
      closePrice = MarketInfo(OrderSymbol(), MODE_BID);
   else if(orderType == OP_SELL)
      closePrice = MarketInfo(OrderSymbol(), MODE_ASK);
   else
      return false; // Should never happen due to the check above
      
   // Close the order
   bool result = OrderClose(ticket, lots, closePrice, m_slippage);
   
   if(!result)
   {
      int errorCode = GetLastError();
      Print("Error closing order #", ticket, ": ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   m_ordersClosed++;
   Print("Order #", ticket, " closed successfully. Lots: ", lots, ", Price: ", closePrice);
   
   return true;
}

//+------------------------------------------------------------------+
//| Close all open orders                                            |
//+------------------------------------------------------------------+
bool CSVTradeManager::CloseAllOrders()
{
   if(!m_isInitialized)
      return false;
      
   bool result = true;
   
   // First, count the orders to build an array of tickets
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderMagicNumber() == m_magicNumber)
         {
            count++;
         }
      }
   }
   
   if(count == 0)
   {
      Print("No orders to close.");
      return true; // No orders to close
   }
      
   int tickets[];
   ArrayResize(tickets, count);
   
   // Fill the array with order tickets
   int idx = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderMagicNumber() == m_magicNumber)
         {
            tickets[idx++] = OrderTicket();
         }
      }
   }
   
   // Close each order
   for(int i = 0; i < count; i++)
   {
      if(!CloseOrder(tickets[i]))
      {
         result = false;
         Print("Failed to close order #", tickets[i]);
      }
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Delete a pending order                                           |
//+------------------------------------------------------------------+
bool CSVTradeManager::DeletePendingOrder(int ticket)
{
   if(!m_isInitialized || ticket <= 0)
      return false;
      
   // Select the order
   if(!OrderSelect(ticket, SELECT_BY_TICKET))
   {
      int errorCode = GetLastError();
      Print("Error selecting order #", ticket, " for deletion: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Check if the order belongs to our EA
   if(OrderMagicNumber() != m_magicNumber)
   {
      Print("Cannot delete order #", ticket, " - it does not belong to this EA.");
      return false;
   }
      
   // Check if the order is still pending
   int orderType = OrderType();
   if(orderType <= OP_SELL)
   {
      Print("Order #", ticket, " is not a pending order.");
      return false;
   }
      
   // Delete the pending order
   bool result = OrderDelete(ticket);
   
   if(!result)
   {
      int errorCode = GetLastError();
      Print("Error deleting order #", ticket, ": ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   Print("Pending order #", ticket, " deleted successfully.");
   
   return true;
}

//+------------------------------------------------------------------+
//| Delete all pending orders                                        |
//+------------------------------------------------------------------+
bool CSVTradeManager::DeleteAllPendingOrders()
{
   if(!m_isInitialized)
      return false;
      
   bool result = true;
   
   // First, count the pending orders to build an array of tickets
   int count = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderMagicNumber() == m_magicNumber && OrderType() > OP_SELL)
         {
            count++;
         }
      }
   }
   
   if(count == 0)
   {
      Print("No pending orders to delete.");
      return true; // No pending orders to delete
   }
      
   int tickets[];
   ArrayResize(tickets, count);
   
   // Fill the array with order tickets
   int idx = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderMagicNumber() == m_magicNumber && OrderType() > OP_SELL)
         {
            tickets[idx++] = OrderTicket();
         }
      }
   }
   
   // Delete each pending order
   for(int i = 0; i < count; i++)
   {
      if(!DeletePendingOrder(tickets[i]))
      {
         result = false;
         Print("Failed to delete pending order #", tickets[i]);
      }
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Get details of an order                                          |
//+------------------------------------------------------------------+
bool CSVTradeManager::GetOrderDetails(int ticket, int &type, double &openPrice, double &lots, 
                                    double &stopLoss, double &takeProfit)
{
   if(ticket <= 0)
      return false;
      
   // Select the order
   if(!OrderSelect(ticket, SELECT_BY_TICKET))
   {
      int errorCode = GetLastError();
      Print("Error selecting order #", ticket, " for details: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Get order details
   type = OrderType();
   openPrice = OrderOpenPrice();
   lots = OrderLots();
   stopLoss = OrderStopLoss();
   takeProfit = OrderTakeProfit();
   
   return true;
}

//+------------------------------------------------------------------+
//| Validate trade parameters                                        |
//+------------------------------------------------------------------+
bool CSVTradeManager::ValidateTradeParameters(string symbol, double lotSize, double stopLoss, double takeProfit)
{
   // Check symbol
   if(symbol == "" || symbol == NULL)
   {
      Print("Invalid symbol");
      return false;
   }
   
   // Check lot size
   double minLot = MarketInfo(symbol, MODE_MINLOT);
   double maxLot = MarketInfo(symbol, MODE_MAXLOT);
   
   if(lotSize < minLot || lotSize > maxLot)
   {
      Print("Invalid lot size: ", lotSize, ". Must be between ", minLot, " and ", maxLot);
      return false;
   }
   
   // Lot size must be a multiple of the lot step
   double lotStep = MarketInfo(symbol, MODE_LOTSTEP);
   if(MathAbs(MathMod(lotSize, lotStep)) > 0.00001)
   {
      Print("Invalid lot size: ", lotSize, ". Must be a multiple of ", lotStep);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if an order is still valid and open                        |
//+------------------------------------------------------------------+
bool CSVTradeManager::IsOrderStillValid(int ticket)
{
   if(ticket <= 0)
      return false;
      
   // Try to select the order
   if(!OrderSelect(ticket, SELECT_BY_TICKET))
      return false;
      
   // Check if it's our order
   if(OrderMagicNumber() != m_magicNumber)
      return false;
      
   // Check if it's still open
   if(OrderCloseTime() > 0)
      return false;
      
   return true;
}
