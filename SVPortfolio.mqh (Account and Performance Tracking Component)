//+------------------------------------------------------------------+
//|                                                   SVPortfolio.mqh |
//+------------------------------------------------------------------+
#property copyright "ScalpingVortex"
#property link      "https://github.com/H3NST7/ScalpingVortex"
#property version   "1.00"
#property strict

// Forward declarations to break circular dependencies
class CSVTradeManager;

//+------------------------------------------------------------------+
//| Portfolio class for managing positions and trade statistics       |
//+------------------------------------------------------------------+
class CSVPortfolio
{
private:
   // Account metrics
   double            m_accountBalance;
   double            m_accountEquity;
   double            m_drawdown;
   double            m_maxDrawdown;
   datetime          m_lastUpdateTime;
   
   // Trade statistics
   int               m_totalTrades;
   int               m_winningTrades;
   int               m_losingTrades;
   double            m_totalProfit;
   double            m_totalLoss;
   double            m_profitFactor;
   
   // Daily statistics
   double            m_dailyProfit;
   datetime          m_lastDayChecked;

public:
                     CSVPortfolio();
                     ~CSVPortfolio();
   
   // Core functionality
   bool              Initialize();
   bool              Update();
   bool              UpdateDailyStats();
   bool              UpdateDrawdownStats();
   int               CountOpenPositions();
   bool              UpdateTradeStatistics();
   
   // Risk management calculations
   double            CalculateLotSizeFromRisk(string symbol, double riskPercent, double stopLossPoints);
   double            GetRiskAmountForLotSize(string symbol, double lotSize, double stopLossPoints);
   double            GetStopLossAmount(string symbol, double lotSize, double stopLossPoints);
   double            GetPipValue(string symbol);
   
   // Getters for statistics
   double            GetDrawdown() const { return m_drawdown; }
   double            GetMaxDrawdown() const { return m_maxDrawdown; }
   double            GetProfitFactor() const { return m_profitFactor; }
   int               GetTotalTrades() const { return m_totalTrades; }
   int               GetWinningTrades() const { return m_winningTrades; }
   int               GetLosingTrades() const { return m_losingTrades; }
   double            GetDailyProfit() const { return m_dailyProfit; }
};

//+------------------------------------------------------------------+
//| Constructor                                                      |
//+------------------------------------------------------------------+
CSVPortfolio::CSVPortfolio()
{
   m_accountBalance = 0.0;
   m_accountEquity = 0.0;
   m_drawdown = 0.0;
   m_maxDrawdown = 0.0;
   m_lastUpdateTime = 0;
   
   m_totalTrades = 0;
   m_winningTrades = 0;
   m_losingTrades = 0;
   m_totalProfit = 0.0;
   m_totalLoss = 0.0;
   m_profitFactor = 0.0;
   
   m_dailyProfit = 0.0;
   m_lastDayChecked = 0;
}

//+------------------------------------------------------------------+
//| Destructor                                                       |
//+------------------------------------------------------------------+
CSVPortfolio::~CSVPortfolio()
{
   // Clean up resources if any
}

//+------------------------------------------------------------------+
//| Initialize the portfolio                                         |
//+------------------------------------------------------------------+
bool CSVPortfolio::Initialize()
{
   m_accountBalance = AccountBalance();
   m_accountEquity = AccountEquity();
   m_lastUpdateTime = TimeCurrent();
   m_lastDayChecked = TimeCurrent();
   
   // Initialize trade statistics from history
   UpdateTradeStatistics();
   
   return true;
}

//+------------------------------------------------------------------+
//| Update portfolio data                                            |
//+------------------------------------------------------------------+
bool CSVPortfolio::Update()
{
   // Update account metrics
   m_accountBalance = AccountBalance();
   m_accountEquity = AccountEquity();
   
   // Update statistics
   UpdateDrawdownStats();
   
   // Check if we need to update daily stats (day change)
   datetime currentTime = TimeCurrent();
   MqlDateTime dtCurrent, dtLast;
   TimeToStruct(currentTime, dtCurrent);
   TimeToStruct(m_lastUpdateTime, dtLast);
   
   if(dtCurrent.day != dtLast.day || dtCurrent.mon != dtLast.mon)
   {
      UpdateDailyStats();
   }
   
   m_lastUpdateTime = currentTime;
   
   return true;
}

//+------------------------------------------------------------------+
//| Update daily statistics                                          |
//+------------------------------------------------------------------+
bool CSVPortfolio::UpdateDailyStats()
{
   // Reset daily profit and update last day checked
   m_dailyProfit = 0.0;
   m_lastDayChecked = TimeCurrent();
   
   // Calculate today's profit from history
   datetime todayStart = StringToTime(TimeToString(TimeCurrent(), TIME_DATE));
   
   for(int i = 0; i < OrdersHistoryTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY))
      {
         // Check if the order closed today
         if(OrderCloseTime() >= todayStart)
         {
            // Only count orders with our magic number
            if(OrderMagicNumber() == 12345) // Should match your system's magic number
            {
               m_dailyProfit += OrderProfit() + OrderSwap() + OrderCommission();
            }
         }
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Update drawdown statistics                                       |
//+------------------------------------------------------------------+
bool CSVPortfolio::UpdateDrawdownStats()
{
   // Calculate current drawdown
   if(m_accountBalance > 0)
   {
      m_drawdown = (m_accountBalance - m_accountEquity) / m_accountBalance * 100.0;
      
      // Update max drawdown if current drawdown is higher
      if(m_drawdown > m_maxDrawdown)
      {
         m_maxDrawdown = m_drawdown;
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Count the number of currently open positions                     |
//+------------------------------------------------------------------+
int CSVPortfolio::CountOpenPositions()
{
   int count = 0;
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderMagicNumber() == 12345) // Replace with your system's magic number
         {
            count++;
         }
      }
   }
   
   return count;
}

//+------------------------------------------------------------------+
//| Update trade statistics                                          |
//+------------------------------------------------------------------+
bool CSVPortfolio::UpdateTradeStatistics()
{
   // Reset statistics
   m_totalTrades = 0;
   m_winningTrades = 0;
   m_losingTrades = 0;
   m_totalProfit = 0.0;
   m_totalLoss = 0.0;
   
   // Iterate through history
   int totalOrders = OrdersHistoryTotal();
   
   for(int i = 0; i < totalOrders; i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY))
      {
         // Check if the order belongs to our EA
         if(OrderMagicNumber() == 12345) // Replace with your system's magic number
         {
            double orderResult = OrderProfit() + OrderSwap() + OrderCommission();
            
            m_totalTrades++;
            
            // Check if the trade was profitable
            if(orderResult > 0)
            {
               m_winningTrades++;
               m_totalProfit += orderResult;
            }
            else
            {
               m_losingTrades++;
               m_totalLoss += orderResult; // OrderProfit() is negative here
            }
         }
      }
   }
   
   // Calculate profit factor
   if(m_totalLoss < 0.0 && MathAbs(m_totalLoss) > 0.0001)
   {
      m_profitFactor = MathAbs(m_totalProfit / m_totalLoss);
   }
   else if(m_totalProfit > 0 && m_totalLoss == 0)
   {
      // All trades are winners
      m_profitFactor = 100.0; // Arbitrarily high value
   }
   else
   {
      m_profitFactor = 0.0;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Calculate lot size based on risk percentage and stop loss points  |
//+------------------------------------------------------------------+
double CSVPortfolio::CalculateLotSizeFromRisk(string symbol, double riskPercent, double stopLossPoints)
{
   if(stopLossPoints <= 0.0 || riskPercent <= 0.0)
      return 0.0;
   
   double balance = AccountBalance();
   double riskAmount = balance * riskPercent / 100.0;
   double pipValue = GetPipValue(symbol);
   
   if(pipValue <= 0.0)
      return 0.0;
   
   double lotSize = riskAmount / (stopLossPoints * pipValue);
   
   // Normalize lot size based on broker constraints
   double minLot = MarketInfo(symbol, MODE_MINLOT);
   double maxLot = MarketInfo(symbol, MODE_MAXLOT);
   double lotStep = MarketInfo(symbol, MODE_LOTSTEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, NormalizeDouble(lotSize / lotStep, 0) * lotStep));
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Calculate risk amount for a given lot size and stop loss points   |
//+------------------------------------------------------------------+
double CSVPortfolio::GetRiskAmountForLotSize(string symbol, double lotSize, double stopLossPoints)
{
   if(stopLossPoints <= 0.0 || lotSize <= 0.0)
      return 0.0;
      
   double pipValue = GetPipValue(symbol);
   
   return lotSize * stopLossPoints * pipValue;
}

//+------------------------------------------------------------------+
//| Calculate stop loss amount for a given lot size and points        |
//+------------------------------------------------------------------+
double CSVPortfolio::GetStopLossAmount(string symbol, double lotSize, double stopLossPoints)
{
   if(stopLossPoints <= 0.0 || lotSize <= 0.0)
      return 0.0;
      
   double pipValue = GetPipValue(symbol);
   
   return lotSize * stopLossPoints * pipValue;
}

//+------------------------------------------------------------------+
//| Calculate pip value for a given symbol                           |
//+------------------------------------------------------------------+
double CSVPortfolio::GetPipValue(string symbol)
{
   double tickSize = MarketInfo(symbol, MODE_TICKSIZE);
   double tickValue = MarketInfo(symbol, MODE_TICKVALUE);
   double point = MarketInfo(symbol, MODE_POINT);
   int digits = (int)MarketInfo(symbol, MODE_DIGITS);
   
   // Determine pip size based on digits
   double pipSize;
   if(digits == 3 || digits == 5)
      pipSize = 0.0001; // 5 digit broker (JPY pairs with 3 digits)
   else
      pipSize = 0.01;   // 4 digit broker (JPY pairs with 2 digits)
   
   // Calculate pip value
   double pipValue = tickValue * (pipSize / tickSize);
   
   return pipValue;
}
