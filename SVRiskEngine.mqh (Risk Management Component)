//+------------------------------------------------------------------+
//|                                                SVRiskEngine.mqh |
//|                                           Copyright 2025, H3nst7 |
//|                                           https://www.h3nst7.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, H3nst7"
#property link      "https://www.h3nst7.com"
#property strict

#include "ScalpingVortex\SVUtils.mqh"
#include "ScalpingVortex\SVMarketAnalyzer.mqh"
#include "ScalpingVortex\SVPortfolio.mqh"

// Structure to hold signal information
struct SVSignalInfo
{
   datetime time;           // Signal time
   ENUM_ORDER_TYPE type;    // Order type
   double entryPrice;       // Entry price
   double stopLoss;         // Stop loss price
   double takeProfit;       // Take profit price
   double lotSize;          // Lot size
   string comment;          // Signal comment
   
   void Clear()
   {
      time = 0;
      type = ORDER_TYPE_BUY;
      entryPrice = 0.0;
      stopLoss = 0.0;
      takeProfit = 0.0;
      lotSize = 0.0;
      comment = "";
   }
};

// Risk Engine class
class CSVRiskEngine
{
private:
   // Risk parameters
   double m_riskPerTrade;           // Risk per trade (% of balance)
   double m_maxDailyRiskPercent;    // Maximum daily risk (% of balance)
   int m_maxConcurrentTrades;       // Maximum number of concurrent trades
   bool m_enableBreakEven;          // Enable break-even feature
   double m_breakEvenAfterPips;     // Move SL to BE after X pips profit
   
   // References to other components
   CSVPortfolio* m_portfolio;       // Portfolio reference
   CSVMarketAnalyzer* m_analyzer;   // Market analyzer reference
   
   // Risk calculation helpers
   double CalculatePositionSize(double entryPrice, double stopLoss, ENUM_ORDER_TYPE orderType);
   double CalculatePositionSizeVolatilityAdjusted(double entryPrice, double stopLoss, ENUM_ORDER_TYPE orderType, double atrMultiplier);
   
   double CalculateATRBasedStopLoss(ENUM_ORDER_TYPE orderType, double entryPrice, double atrMultiplier);
   double CalculateATRBasedTakeProfit(ENUM_ORDER_TYPE orderType, double entryPrice, double atrMultiplier);
   
   double GetCurrentTotalRiskExposure();
   bool IsBreakEvenEligible(ulong positionTicket);
   void ApplyBreakEven(ulong positionTicket);
   
public:
   // Constructor and destructor
   CSVRiskEngine();
   ~CSVRiskEngine();
   
   // Initialization
   bool Initialize(
      double riskPerTrade,
      double maxDailyRiskPercent,
      int maxConcurrentTrades,
      bool enableBreakEven,
      double breakEvenAfterPips,
      CSVPortfolio* portfolio,
      CSVMarketAnalyzer* analyzer
   );
   
   // Risk validation and management
   bool ValidateAndAdjustEntrySignal(SVSignalInfo &signal, ENUM_ORDER_TYPE orderType);
   bool ProcessOpenPosition(ulong positionTicket);
   bool IsTradingAllowed();
   
   // Risk parameter getters
   double GetRiskPerTrade() const { return m_riskPerTrade; }
   double GetMaxDailyRiskPercent() const { return m_maxDailyRiskPercent; }
   int GetMaxConcurrentTrades() const { return m_maxConcurrentTrades; }
   bool GetEnableBreakEven() const { return m_enableBreakEven; }
   double GetBreakEvenAfterPips() const { return m_breakEvenAfterPips; }
   
   // Risk parameter setters
   void SetRiskPerTrade(double riskPerTrade) { m_riskPerTrade = riskPerTrade; }
   void SetMaxDailyRiskPercent(double maxDailyRiskPercent) { m_maxDailyRiskPercent = maxDailyRiskPercent; }
   void SetMaxConcurrentTrades(int maxConcurrentTrades) { m_maxConcurrentTrades = maxConcurrentTrades; }
   void SetEnableBreakEven(bool enableBreakEven) { m_enableBreakEven = enableBreakEven; }
   void SetBreakEvenAfterPips(double breakEvenAfterPips) { m_breakEvenAfterPips = breakEvenAfterPips; }
};

//+------------------------------------------------------------------+
//| Constructor                                                      |
//+------------------------------------------------------------------+
CSVRiskEngine::CSVRiskEngine()
{
   m_riskPerTrade = 1.0;            // Default 1% risk per trade
   m_maxDailyRiskPercent = 5.0;     // Default 5% max daily risk
   m_maxConcurrentTrades = 3;       // Default 3 concurrent trades max
   m_enableBreakEven = true;        // Default enable break-even
   m_breakEvenAfterPips = 5.0;      // Default 5 pips for break-even
   
   m_portfolio = NULL;
   m_analyzer = NULL;
}

//+------------------------------------------------------------------+
//| Destructor                                                       |
//+------------------------------------------------------------------+
CSVRiskEngine::~CSVRiskEngine()
{
   // No dynamic memory to free
}

//+------------------------------------------------------------------+
//| Initialize risk engine with parameters                           |
//+------------------------------------------------------------------+
bool CSVRiskEngine::Initialize(
   double riskPerTrade,
   double maxDailyRiskPercent,
   int maxConcurrentTrades,
   bool enableBreakEven,
   double breakEvenAfterPips,
   CSVPortfolio* portfolio,
   CSVMarketAnalyzer* analyzer
)
{
   if(portfolio == NULL || analyzer == NULL) {
      CSVUtils::Log(LOG_LEVEL_ERROR, __FUNCTION__, "Portfolio or Market Analyzer reference is NULL");
      return false;
   }
   
   // Store risk parameters
   m_riskPerTrade = riskPerTrade;
   m_maxDailyRiskPercent = maxDailyRiskPercent;
   m_maxConcurrentTrades = maxConcurrentTrades;
   m_enableBreakEven = enableBreakEven;
   m_breakEvenAfterPips = breakEvenAfterPips;
   
   // Store component references
   m_portfolio = portfolio;
   m_analyzer = analyzer;
   
   CSVUtils::Log(LOG_LEVEL_INFO, __FUNCTION__, "Risk Engine initialized with risk per trade: " + 
                DoubleToString(m_riskPerTrade, 2) + "%, max daily risk: " + 
                DoubleToString(m_maxDailyRiskPercent, 2) + "%");
   
   return true;
}

//+------------------------------------------------------------------+
//| Validate and adjust entry signal                                 |
//+------------------------------------------------------------------+
bool CSVRiskEngine::ValidateAndAdjustEntrySignal(SVSignalInfo &signal, ENUM_ORDER_TYPE orderType)
{
   // Check if trading is allowed
   if(!IsTradingAllowed()) {
      CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Trading not allowed due to risk limits");
      return false;
   }
   
   // Ensure order type is set
   signal.type = orderType;
   
   // Set entry price if not provided
   if(signal.entryPrice <= 0.0) {
      if(orderType == ORDER_TYPE_BUY) {
         signal.entryPrice = m_analyzer.GetAsk();
      } else {
         signal.entryPrice = m_analyzer.GetBid();
      }
   }
   
   // Calculate ATR-based stop loss if not provided
   if(signal.stopLoss <= 0.0) {
      signal.stopLoss = CalculateATRBasedStopLoss(orderType, signal.entryPrice, 1.5);
   }
   
   // Calculate ATR-based take profit if not provided
   if(signal.takeProfit <= 0.0) {
      signal.takeProfit = CalculateATRBasedTakeProfit(orderType, signal.entryPrice, 2.0);
   }
   
   // Validate stop loss and take profit distances
   double minStopDistancePips = 5.0; // Minimum 5 pips for XAUUSD
   double entryToStopPips;
   
   if(orderType == ORDER_TYPE_BUY) {
      entryToStopPips = CSVUtils::PriceToPips(signal.entryPrice - signal.stopLoss);
      
      // Ensure stop loss is below entry price
      if(signal.stopLoss >= signal.entryPrice) {
         CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Invalid SL - must be below entry for BUY");
         return false;
      }
      
      // Ensure take profit is above entry price
      if(signal.takeProfit <= signal.entryPrice) {
         CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Invalid TP - must be above entry for BUY");
         return false;
      }
   } else {
      entryToStopPips = CSVUtils::PriceToPips(signal.stopLoss - signal.entryPrice);
      
      // Ensure stop loss is above entry price
      if(signal.stopLoss <= signal.entryPrice) {
         CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Invalid SL - must be above entry for SELL");
         return false;
      }
      
      // Ensure take profit is below entry price
      if(signal.takeProfit >= signal.entryPrice) {
         CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Invalid TP - must be below entry for SELL");
         return false;
      }
   }
   
   // Check minimum stop distance
   if(entryToStopPips < minStopDistancePips) {
      CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Stop loss too close to entry price: " + 
                   DoubleToString(entryToStopPips, 2) + " pips");
      return false;
   }
   
   // Calculate risk-adjusted position size based on stop loss
   signal.lotSize = CalculatePositionSizeVolatilityAdjusted(signal.entryPrice, signal.stopLoss, orderType, 1.0);
   
   // Ensure lot size is valid
   if(signal.lotSize <= 0.0) {
      CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Invalid lot size: " + DoubleToString(signal.lotSize, 2));
      return false;
   }
   
   // Get current total risk exposure
   double currentRiskExposure = GetCurrentTotalRiskExposure();
   double entryRiskAmount = m_portfolio.GetRiskAmountForLotSize(signal.lotSize, entryToStopPips);
   double entryRiskPercent = (entryRiskAmount / m_portfolio.GetBalance()) * 100.0;
   
   // Ensure we don't exceed maximum risk exposure
   if(currentRiskExposure + entryRiskPercent > m_maxDailyRiskPercent) {
      CSVUtils::Log(LOG_LEVEL_WARNING, __FUNCTION__, "Entry would exceed max daily risk: " + 
                   DoubleToString(currentRiskExposure + entryRiskPercent, 2) + 
                   "% > " + DoubleToString(m_maxDailyRiskPercent, 2) + "%");
      return false;
   }
   
   CSVUtils::Log(LOG_LEVEL_INFO, __FUNCTION__, "Signal validated: " + CSVUtils::OrderTypeToString(orderType) + 
                " Entry: " + DoubleToString(signal.entryPrice, 2) + 
                " SL: " + DoubleToString(signal.stopLoss, 2) + 
                " TP: " + DoubleToString(signal.takeProfit, 2) + 
                " Lot: " + DoubleToString(signal.lotSize, 2));
   
   return true;
}

//+------------------------------------------------------------------+
//| Process an open position for risk management                     |
//+------------------------------------------------------------------+
bool CSVRiskEngine::ProcessOpenPosition(ulong positionTicket)
{
   if(!PositionSelectByTicket(positionTicket)) {
      return false;
   }
   
   // Check if position belongs to our EA
   ulong magic = PositionGetInteger(POSITION_MAGIC);
   if(magic != m_portfolio.GetMagicNumber()) {
      return false;
   }
   
   // Apply break-even if enabled and conditions met
   if(m_enableBreakEven && IsBreakEvenEligible(positionTicket)) {
      ApplyBreakEven(positionTicket);
   }
   
   // TODO: Implement trailing stop logic here if needed
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if trading is allowed based on risk limits                 |
//+------------------------------------------------------------------+
bool CSVRiskEngine::IsTradingAllowed()
{
   // Check if max concurrent trades limit is reached
   int currentTrades = m_portfolio.GetOpenPositionsCount();
   if(currentTrades >= m_maxConcurrentTrades) {
      return false;
   }
   
   // Check if daily risk limit is reached
   double currentDailyDrawdown = m_portfolio.GetDailyDrawdownPercent();
   if(currentDailyDrawdown >= m_maxDailyRiskPercent) {
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Calculate position size based on fixed risk percentage           |
//+------------------------------------------------------------------+
double CSVRiskEngine::CalculatePositionSize(double entryPrice, double stopLoss, ENUM_ORDER_TYPE orderType)
{
   double riskAmount = m_portfolio.GetBalance() * (m_riskPerTrade / 100.0);
   double stopLossPips;
   
   if(orderType == ORDER_TYPE_BUY) {
      stopLossPips = CSVUtils::PriceToPips(entryPrice - stopLoss);
   } else {
      stopLossPips = CSVUtils::PriceToPips(stopLoss - entryPrice);
   }
   
   // Calculate lot size based on risk amount and stop loss distance
   double lotSize = m_portfolio.CalculateLotSizeFromRisk(riskAmount, stopLossPips);
   
   // Normalize lot size to valid value
   lotSize = CSVUtils::NormalizeLotSize(lotSize);
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Calculate position size with volatility adjustment               |
//+------------------------------------------------------------------+
double CSVRiskEngine::CalculatePositionSizeVolatilityAdjusted(double entryPrice, double stopLoss, ENUM_ORDER_TYPE orderType, double atrMultiplier)
{
   // Get base position size using fixed risk percentage
   double basePositionSize = CalculatePositionSize(entryPrice, stopLoss, orderType);
   
   // Adjust position size based on volatility
   double volatilityIndex = m_analyzer.GetVolatilityIndex();
   double adjustedPositionSize = basePositionSize;
   
   if(volatilityIndex > 1.5) {
      // High volatility - reduce position size
      adjustedPositionSize = basePositionSize / volatilityIndex;
   } else if(volatilityIndex < 0.5) {
      // Low volatility - can potentially increase position size
      // but cap it at 1.5x base size to avoid excessive risk
      adjustedPositionSize = MathMin(basePositionSize * 1.5, basePositionSize / volatilityIndex);
   }
   
   // Normalize lot size to valid value
   adjustedPositionSize = CSVUtils::NormalizeLotSize(adjustedPositionSize);
   
   return adjustedPositionSize;
}

//+------------------------------------------------------------------+
//| Calculate ATR-based stop loss                                    |
//+------------------------------------------------------------------+
double CSVRiskEngine::CalculateATRBasedStopLoss(ENUM_ORDER_TYPE orderType, double entryPrice, double atrMultiplier)
{
   // Get ATR value from M5 timeframe (suitable for scalping)
   double atr = m_analyzer.GetATR(PERIOD_M5, 14, 0);
   
   // Calculate stop loss distance based on ATR
   double stopLossDistance = atr * atrMultiplier;
   
   if(orderType == ORDER_TYPE_BUY) {
      return entryPrice - stopLossDistance;
   } else {
      return entryPrice + stopLossDistance;
   }
}

//+------------------------------------------------------------------+
//| Calculate ATR-based take profit                                  |
//+------------------------------------------------------------------+
double CSVRiskEngine::CalculateATRBasedTakeProfit(ENUM_ORDER_TYPE orderType, double entryPrice, double atrMultiplier)
{
   // Get ATR value from M5 timeframe (suitable for scalping)
   double atr = m_analyzer.GetATR(PERIOD_M5, 14, 0);
   
   // Calculate take profit distance based on ATR
   double takeProfitDistance = atr * atrMultiplier;
   
   if(orderType == ORDER_TYPE_BUY) {
      return entryPrice + takeProfitDistance;
   } else {
      return entryPrice - takeProfitDistance;
   }
}

//+------------------------------------------------------------------+
//| Get current total risk exposure as percentage of balance         |
//+------------------------------------------------------------------+
double CSVRiskEngine::GetCurrentTotalRiskExposure()
{
   double totalRiskAmount = 0.0;
   int totalPositions = PositionsTotal();
   
   for(int i = 0; i < totalPositions; i++) {
      ulong posTicket = PositionGetTicket(i);
      
      if(PositionSelectByTicket(posTicket)) {
         // Skip positions that don't belong to our EA
         if(PositionGetInteger(POSITION_MAGIC) != m_portfolio.GetMagicNumber()) {
            continue;
         }
         
         double posLotSize = PositionGetDouble(POSITION_VOLUME);
         double posStopLoss = PositionGetDouble(POSITION_SL);
         double posEntryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         
         // Calculate stop loss distance in pips
         double slDistancePips;
         
         if(posType == POSITION_TYPE_BUY) {
            slDistancePips = CSVUtils::PriceToPips(posEntryPrice - posStopLoss);
         } else {
            slDistancePips = CSVUtils::PriceToPips(posStopLoss - posEntryPrice);
         }
         
         // Calculate risk amount for this position
         double posRiskAmount = m_portfolio.GetRiskAmountForLotSize(posLotSize, slDistancePips);
         
         // Add to total risk amount
         totalRiskAmount += posRiskAmount;
      }
   }
   
   // Calculate risk as percentage of balance
   double balance = m_portfolio.GetBalance();
   double riskPercent = (balance > 0.0) ? (totalRiskAmount / balance) * 100.0 : 0.0;
   
   return riskPercent;
}

//+------------------------------------------------------------------+
//| Check if position is eligible for break-even                     |
//+------------------------------------------------------------------+
bool CSVRiskEngine::IsBreakEvenEligible(ulong positionTicket)
{
   if(!PositionSelectByTicket(positionTicket)) {
      return false;
   }
   
   double posEntryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double posStopLoss = PositionGetDouble(POSITION_SL);
   double currentPrice = 0.0;
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   
   // Get current bid or ask price depending on position type
   if(posType == POSITION_TYPE_BUY) {
      currentPrice = m_analyzer.GetBid();
   } else {
      currentPrice = m_analyzer.GetAsk();
   }
   
   // Calculate current profit in pips
   double currentProfitPips;
   
   if(posType == POSITION_TYPE_BUY) {
      currentProfitPips = CSVUtils::PriceToPips(currentPrice - posEntryPrice);
   } else {
      currentProfitPips = CSVUtils::PriceToPips(posEntryPrice - currentPrice);
   }
   
   // Check if position is already at break-even
   if(posType == POSITION_TYPE_BUY && posStopLoss >= posEntryPrice) {
      return false;
   } else if(posType == POSITION_TYPE_SELL && posStopLoss <= posEntryPrice) {
      return false;
   }
   
   // Check if current profit is enough to move to break-even
   return (currentProfitPips >= m_breakEvenAfterPips);
}

//+------------------------------------------------------------------+
//| Apply break-even to a position                                   |
//+------------------------------------------------------------------+
void CSVRiskEngine::ApplyBreakEven(ulong positionTicket)
{
   if(!PositionSelectByTicket(positionTicket)) {
      return;
   }
   
   double posEntryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double posStopLoss = PositionGetDouble(POSITION_SL);
   double posTakeProfit = PositionGetDouble(POSITION_TP);
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   
   // Calculate break-even stop loss with 1 pip buffer (in profit)
   double breakEvenSL;
   
   if(posType == POSITION_TYPE_BUY) {
      breakEvenSL = posEntryPrice + CSVUtils::PipsToPrice(1.0);
   } else {
      breakEvenSL = posEntryPrice - CSVUtils::PipsToPrice(1.0);
   }
   
   // Check if current SL is already better than break-even
   if(posType == POSITION_TYPE_BUY && posStopLoss >= breakEvenSL) {
      return;
   } else if(posType == POSITION_TYPE_SELL && posStopLoss <= breakEvenSL) {
      return;
   }
   
   // Create trade object for position modification
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_SLTP;
   request.position = positionTicket;
   request.symbol = Symbol();
   request.sl = breakEvenSL;
   request.tp = posTakeProfit; // Keep the same TP
   
   bool success = OrderSend(request, result);
   
   if(success && result.retcode == TRADE_RETCODE_DONE) {
      CSVUtils::Log(LOG_LEVEL_INFO, __FUNCTION__, "Break-even applied for ticket #" + 
                   IntegerToString(positionTicket) + " new SL: " + DoubleToString(breakEvenSL, 2));
   } else {
      CSVUtils::Log(LOG_LEVEL_ERROR, __FUNCTION__, "Failed to apply break-even for ticket #" + 
                   IntegerToString(positionTicket) + " Error: " + 
                   IntegerToString(result.retcode));
   }
}
