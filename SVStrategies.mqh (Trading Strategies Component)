//+------------------------------------------------------------------+
//|                                               SVStrategies.mqh |
//|                                           Copyright 2025, H3nst7 |
//|                                           https://www.h3nst7.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, H3nst7"
#property link      "https://www.h3nst7.com"
#property strict

#include "ScalpingVortex\SVUtils.mqh"
#include "ScalpingVortex\SVMarketAnalyzer.mqh"
#include "ScalpingVortex\SVRiskEngine.mqh"

// Base abstract class for strategies
class CSVStrategyBase
{
protected:
   string m_strategyID;             // Unique strategy identifier
   string m_strategyName;           // Human-readable strategy name
   CSVMarketAnalyzer* m_analyzer;   // Market analyzer reference
   CSVRiskEngine* m_riskEngine;     // Risk engine reference
   
   // Strategy-specific parameters
   double m_minProfitPips;          // Minimum profit target in pips
   double m_atrMultiplierSL;        // ATR multiplier for stop loss
   double m_atrMultiplierTP;        // ATR multiplier for take profit
   
public:
   // Constructor and destructor
   CSVStrategyBase();
   virtual ~CSVStrategyBase();
   
   // Initialization
   virtual bool Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine);
   
   // Abstract methods that must be implemented by derived strategies
   virtual bool CheckEntrySignalLong(SVSignalInfo &signal) = 0;
   virtual bool CheckEntrySignalShort(SVSignalInfo &signal) = 0;
   virtual bool CheckExitSignal(ulong positionTicket, string &exitReason) = 0;
   
   // Getters
   string GetStrategyID() const { return m_strategyID; }
   string GetStrategyName() const { return m_strategyName; }
};

//+------------------------------------------------------------------+
//| Range Fade Scalper Strategy                                      |
//+------------------------------------------------------------------+
class CSVRangeFadeScalper : public CSVStrategyBase
{
private:
   // Range identification parameters
   int m_rangePeriod;               // Number of bars to check for range
   int m_lookbackBars;              // Lookback period for range detection
   double m_rangeThreshold;         // Range threshold as percentage
   
   // Entry parameters
   double m_entryLevel;             // Entry level as percentage from range boundary
   double m_overboughtLevel;        // RSI overbought level
   double m_oversoldLevel;          // RSI oversold level
   
   // Helper methods
   bool IdentifyRange(double &rangeHigh, double &rangeLow, int &rangeStartBar);
   bool IsOverbought();
   bool IsOversold();
   
public:
   // Constructor and destructor
   CSVRangeFadeScalper();
   virtual ~CSVRangeFadeScalper();
   
   // Initialization
   virtual bool Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine);
   
   // Signal methods
   virtual bool CheckEntrySignalLong(SVSignalInfo &signal);
   virtual bool CheckEntrySignalShort(SVSignalInfo &signal);
   virtual bool CheckExitSignal(ulong positionTicket, string &exitReason);
};

//+------------------------------------------------------------------+
//| Impulse Rider Scalper Strategy                                   |
//+------------------------------------------------------------------+
class CSVImpulseRiderScalper : public CSVStrategyBase
{
private:
   // Impulse detection parameters
   int m_momentumPeriod;            // Period for momentum indicator
   double m_momentumThreshold;      // Threshold for momentum
   double m_volumeSpikeThreshold;   // Volume spike threshold
   
   // Confirmation parameters
   int m_emaPeriodFast;             // Fast EMA period
   int m_emaPeriodSlow;             // Slow EMA period
   
   // Helper methods
   bool DetectBullishImpulse();
   bool DetectBearishImpulse();
   bool IsMomentumStrong(bool bullish);
   bool IsVolumeSpiking();
   
public:
   // Constructor and destructor
   CSVImpulseRiderScalper();
   virtual ~CSVImpulseRiderScalper();
   
   // Initialization
   virtual bool Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine);
   
   // Signal methods
   virtual bool CheckEntrySignalLong(SVSignalInfo &signal);
   virtual bool CheckEntrySignalShort(SVSignalInfo &signal);
   virtual bool CheckExitSignal(ulong positionTicket, string &exitReason);
};

//+------------------------------------------------------------------+
//| Base Strategy Constructor                                        |
//+------------------------------------------------------------------+
CSVStrategyBase::CSVStrategyBase()
{
   m_strategyID = "BASE";
   m_strategyName = "Base Strategy";
   m_analyzer = NULL;
   m_riskEngine = NULL;
   
   m_minProfitPips = 5.0;
   m_atrMultiplierSL = 1.5;
   m_atrMultiplierTP = 2.0;
}

//+------------------------------------------------------------------+
//| Base Strategy Destructor                                         |
//+------------------------------------------------------------------+
CSVStrategyBase::~CSVStrategyBase()
{
   // No dynamic memory to free
}

//+------------------------------------------------------------------+
//| Base Strategy Initialization                                     |
//+------------------------------------------------------------------+
bool CSVStrategyBase::Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine)
{
   if(analyzer == NULL || riskEngine == NULL) {
      CSVUtils::Log(LOG_LEVEL_ERROR, __FUNCTION__, m_strategyName + ": Invalid analyzer or risk engine reference");
      return false;
   }
   
   m_analyzer = analyzer;
   m_riskEngine = riskEngine;
   
   return true;
}

//+------------------------------------------------------------------+
//| Range Fade Scalper Constructor                                   |
//+------------------------------------------------------------------+
CSVRangeFadeScalper::CSVRangeFadeScalper()
{
   m_strategyID = "RANGE_FADE";
   m_strategyName = "Range Fade Scalper";
   
   // Default strategy parameters
   m_rangePeriod = 10;           // 10 bars for range
   m_lookbackBars = 20;          // 20 bars lookback
   m_rangeThreshold = 0.2;       // 0.2% range
   m_entryLevel = 0.8;           // 80% from range boundary
   m_overboughtLevel = 70.0;     // RSI overbought level
   m_oversoldLevel = 30.0;       // RSI oversold level
   
   // ATR for SL/TP
   m_atrMultiplierSL = 1.2;      // Tighter SL for range strategy
   m_atrMultiplierTP = 1.0;      // Conservative TP for range strategy
}

//+------------------------------------------------------------------+
//| Range Fade Scalper Destructor                                    |
//+------------------------------------------------------------------+
CSVRangeFadeScalper::~CSVRangeFadeScalper()
{
   // No dynamic memory to free
}

//+------------------------------------------------------------------+
//| Range Fade Scalper Initialization                                |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine)
{
   if(!CSVStrategyBase::Initialize(analyzer, riskEngine)) {
      return false;
   }
   
   CSVUtils::Log(LOG_LEVEL_INFO, __FUNCTION__, m_strategyName + " initialized");
   return true;
}

//+------------------------------------------------------------------+
//| Check for long entry signal                                      |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::CheckEntrySignalLong(SVSignalInfo &signal)
{
   // Clear previous signal
   signal.Clear();
   
   // Identify current range
   double rangeHigh, rangeLow;
   int rangeStartBar;
   
   if(!IdentifyRange(rangeHigh, rangeLow, rangeStartBar)) {
      // No valid range detected
      return false;
   }
   
   // Calculate range size
   double rangeSize = rangeHigh - rangeLow;
   double currentPrice = m_analyzer.GetBid();
   
   // Check if price is near bottom of range
   double entryZone = rangeLow + (rangeSize * 0.2); // Bottom 20% of range
   
   if(currentPrice > entryZone) {
      // Price not in entry zone
      return false;
   }
   
   // Check if market is oversold - additional confirmation
   if(!IsOversold()) {
      // Not oversold by RSI
      return false;
   }
   
   // All conditions met, prepare signal
   signal.time = TimeCurrent();
   signal.type = ORDER_TYPE_BUY;
   signal.entryPrice = m_analyzer.GetAsk();
   
   // Calculate SL and TP
   // SL just below range low with buffer
   signal.stopLoss = rangeLow - m_analyzer.GetATR(PERIOD_M5, 14, 0) * 0.5;
   
   // TP at range midpoint or better
   signal.takeProfit = rangeLow + (rangeSize * 0.5);
   
   // Let risk engine calculate proper lot size
   signal.lotSize = 0.0; // To be filled by risk engine
   
   // Add strategy identifier to comment
   signal.comment = m_strategyID + ": Range fade long at range bottom";
   
   CSVUtils::Log(LOG_LEVEL_DEBUG, __FUNCTION__, m_strategyName + " generated LONG signal");
   return true;
}

//+------------------------------------------------------------------+
//| Check for short entry signal                                     |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::CheckEntrySignalShort(SVSignalInfo &signal)
{
   // Clear previous signal
   signal.Clear();
   
   // Identify current range
   double rangeHigh, rangeLow;
   int rangeStartBar;
   
   if(!IdentifyRange(rangeHigh, rangeLow, rangeStartBar)) {
      // No valid range detected
      return false;
   }
   
   // Calculate range size
   double rangeSize = rangeHigh - rangeLow;
   double currentPrice = m_analyzer.GetAsk();
   
   // Check if price is near top of range
   double entryZone = rangeHigh - (rangeSize * 0.2); // Top 20% of range
   
   if(currentPrice < entryZone) {
      // Price not in entry zone
      return false;
   }
   
   // Check if market is overbought - additional confirmation
   if(!IsOverbought()) {
      // Not overbought by RSI
      return false;
   }
   
   // All conditions met, prepare signal
   signal.time = TimeCurrent();
   signal.type = ORDER_TYPE_SELL;
   signal.entryPrice = m_analyzer.GetBid();
   
   // Calculate SL and TP
   // SL just above range high with buffer
   signal.stopLoss = rangeHigh + m_analyzer.GetATR(PERIOD_M5, 14, 0) * 0.5;
   
   // TP at range midpoint or better
   signal.takeProfit = rangeHigh - (rangeSize * 0.5);
   
   // Let risk engine calculate proper lot size
   signal.lotSize = 0.0; // To be filled by risk engine
   
   // Add strategy identifier to comment
   signal.comment = m_strategyID + ": Range fade short at range top";
   
   CSVUtils::Log(LOG_LEVEL_DEBUG, __FUNCTION__, m_strategyName + " generated SHORT signal");
   return true;
}

//+------------------------------------------------------------------+
//| Check for exit signal                                            |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::CheckExitSignal(ulong positionTicket, string &exitReason)
{
   if(!PositionSelectByTicket(positionTicket)) {
      return false;
   }
   
   // Get position data
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   string posComment = PositionGetString(POSITION_COMMENT);
   double posProfit = PositionGetDouble(POSITION_PROFIT);
   double posVolume = PositionGetDouble(POSITION_VOLUME);
   double posOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   
   // Only manage positions from this strategy
   if(StringFind(posComment, m_strategyID) < 0) {
      return false;
   }
   
   // Check for range breakout (range invalidation)
   double rangeHigh, rangeLow;
   int rangeStartBar;
   
   if(IdentifyRange(rangeHigh, rangeLow, rangeStartBar)) {
      // Range is still valid, check if price is moving out of range
      double currentPrice = (posType == POSITION_TYPE_BUY) ? m_analyzer.GetBid() : m_analyzer.GetAsk();
      
      if(posType == POSITION_TYPE_BUY && currentPrice > rangeHigh) {
         // For long positions, exit if price breaks above range (range not valid)
         exitReason = "Range breakout to upside invalidates fade strategy";
         return true;
      } else if(posType == POSITION_TYPE_SELL && currentPrice < rangeLow) {
         // For short positions, exit if price breaks below range (range not valid)
         exitReason = "Range breakout to downside invalidates fade strategy";
         return true;
      }
   } else {
      // Range no longer valid
      exitReason = "Range structure no longer valid";
      return true;
   }
   
   // Check for opposing signals (RSI)
   if(posType == POSITION_TYPE_BUY && IsOverbought()) {
      // For long positions, exit if market becomes overbought
      exitReason = "Market overbought, taking profit";
      return true;
   } else if(posType == POSITION_TYPE_SELL && IsOversold()) {
      // For short positions, exit if market becomes oversold
      exitReason = "Market oversold, taking profit";
      return true;
   }
   
   // Time-based exit (exit after 10 bars - quick scalping)
   datetime posOpenTime = (datetime)PositionGetInteger(POSITION_TIME);
   datetime currentTime = TimeCurrent();
   int barsSinceOpen = 0;
   
   // Count bars since position opening
   datetime barTimes[];
   ArraySetAsSeries(barTimes, true);
   int copied = CopyTime(Symbol(), PERIOD_M5, 0, 50, barTimes);
   
   if(copied > 0) {
      for(int i = 0; i < copied; i++) {
         if(barTimes[i] <= posOpenTime) {
            barsSinceOpen = i;
            break;
         }
      }
   }
   
   if(barsSinceOpen >= 10) {
      exitReason = "Time-based exit (10 bars passed)";
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Identify price range                                             |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::IdentifyRange(double &rangeHigh, double &rangeLow, int &rangeStartBar)
{
   double highPrices[];
   double lowPrices[];
   double closePrices[];
   
   ArraySetAsSeries(highPrices, true);
   ArraySetAsSeries(lowPrices, true);
   ArraySetAsSeries(closePrices, true);
   
   // Copy price data
   int copied = CopyHigh(Symbol(), PERIOD_M5, 0, m_lookbackBars, highPrices);
   if(copied != m_lookbackBars) return false;
   
   copied = CopyLow(Symbol(), PERIOD_M5, 0, m_lookbackBars, lowPrices);
   if(copied != m_lookbackBars) return false;
   
   copied = CopyClose(Symbol(), PERIOD_M5, 0, m_lookbackBars, closePrices);
   if(copied != m_lookbackBars) return false;
   
   // Find range within lookback period
   for(int i = 0; i < m_lookbackBars - m_rangePeriod; i++) {
      // Find highest high and lowest low in the range window
      double windowHigh = highPrices[i];
      double windowLow = lowPrices[i];
      
      for(int j = i + 1; j < i + m_rangePeriod; j++) {
         if(highPrices[j] > windowHigh) windowHigh = highPrices[j];
         if(lowPrices[j] < windowLow) windowLow = lowPrices[j];
      }
      
      // Calculate range as percentage of average price
      double rangeSize = windowHigh - windowLow;
      double avgPrice = (windowHigh + windowLow) / 2.0;
      double rangePercent = (rangeSize / avgPrice) * 100.0;
      
      // Check if range is tight enough
      if(rangePercent <= m_rangeThreshold) {
         // Check if most recent candles are within the range
         bool withinRange = true;
         
         for(int k = 0; k < 3; k++) {
            if(highPrices[k] > windowHigh || lowPrices[k] < windowLow) {
               withinRange = false;
               break;
            }
         }
         
         if(withinRange) {
            // Found a valid range
            rangeHigh = windowHigh;
            rangeLow = windowLow;
            rangeStartBar = i + m_rangePeriod - 1;
            return true;
         }
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check if market is overbought                                    |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::IsOverbought()
{
   double rsi = m_analyzer.GetRSI(PERIOD_M5, 14, 0);
   return (rsi > m_overboughtLevel);
}

//+------------------------------------------------------------------+
//| Check if market is oversold                                      |
//+------------------------------------------------------------------+
bool CSVRangeFadeScalper::IsOversold()
{
   double rsi = m_analyzer.GetRSI(PERIOD_M5, 14, 0);
   return (rsi < m_oversoldLevel);
}

//+------------------------------------------------------------------+
//| Impulse Rider Scalper Constructor                                |
//+------------------------------------------------------------------+
CSVImpulseRiderScalper::CSVImpulseRiderScalper()
{
   m_strategyID = "IMPULSE_RIDER";
   m_strategyName = "Impulse Rider Scalper";
   
   // Default strategy parameters
   m_momentumPeriod = 5;         // 5-bar momentum
   m_momentumThreshold = 0.3;    // 0.3% threshold
   m_volumeSpikeThreshold = 2.0; // 2x average volume
   
   m_emaPeriodFast = 5;          // 5-period EMA
   m_emaPeriodSlow = 20;         // 20-period EMA
   
   // ATR for SL/TP
   m_atrMultiplierSL = 1.5;      // Standard SL
   m_atrMultiplierTP = 2.0;      // Wider TP for trend-following
}

//+------------------------------------------------------------------+
//| Impulse Rider Scalper Destructor                                 |
//+------------------------------------------------------------------+
CSVImpulseRiderScalper::~CSVImpulseRiderScalper()
{
   // No dynamic memory to free
}

//+------------------------------------------------------------------+
//| Impulse Rider Scalper Initialization                             |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::Initialize(CSVMarketAnalyzer* analyzer, CSVRiskEngine* riskEngine)
{
   if(!CSVStrategyBase::Initialize(analyzer, riskEngine)) {
      return false;
   }
   
   CSVUtils::Log(LOG_LEVEL_INFO, __FUNCTION__, m_strategyName + " initialized");
   return true;
}

//+------------------------------------------------------------------+
//| Check for long entry signal                                      |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::CheckEntrySignalLong(SVSignalInfo &signal)
{
   // Clear previous signal
   signal.Clear();
   
   // Check for bullish impulse
   if(!DetectBullishImpulse()) {
      return false;
   }
   
   // Check for strong momentum
   if(!IsMomentumStrong(true)) {
      return false;
   }
   
   // Check for volume spike (confirmation)
   if(!IsVolumeSpiking()) {
      return false;
   }
   
   // All conditions met, prepare signal
   signal.time = TimeCurrent();
   signal.type = ORDER_TYPE_BUY;
   signal.entryPrice = m_analyzer.GetAsk();
   
   // Calculate ATR-based SL and TP
   double atr = m_analyzer.GetATR(PERIOD_M5, 14, 0);
   signal.stopLoss = signal.entryPrice - (atr * m_atrMultiplierSL);
   signal.takeProfit = signal.entryPrice + (atr * m_atrMultiplierTP);
   
   // Let risk engine calculate proper lot size
   signal.lotSize = 0.0; // To be filled by risk engine
   
   // Add strategy identifier to comment
   signal.comment = m_strategyID + ": Bullish impulse with volume confirmation";
   
   CSVUtils::Log(LOG_LEVEL_DEBUG, __FUNCTION__, m_strategyName + " generated LONG signal");
   return true;
}

//+------------------------------------------------------------------+
//| Check for short entry signal                                     |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::CheckEntrySignalShort(SVSignalInfo &signal)
{
   // Clear previous signal
   signal.Clear();
   
   // Check for bearish impulse
   if(!DetectBearishImpulse()) {
      return false;
   }
   
   // Check for strong momentum
   if(!IsMomentumStrong(false)) {
      return false;
   }
   
   // Check for volume spike (confirmation)
   if(!IsVolumeSpiking()) {
      return false;
   }
   
   // All conditions met, prepare signal
   signal.time = TimeCurrent();
   signal.type = ORDER_TYPE_SELL;
   signal.entryPrice = m_analyzer.GetBid();
   
   // Calculate ATR-based SL and TP
   double atr = m_analyzer.GetATR(PERIOD_M5, 14, 0);
   signal.stopLoss = signal.entryPrice + (atr * m_atrMultiplierSL);
   signal.takeProfit = signal.entryPrice - (atr * m_atrMultiplierTP);
   
   // Let risk engine calculate proper lot size
   signal.lotSize = 0.0; // To be filled by risk engine
   
   // Add strategy identifier to comment
   signal.comment = m_strategyID + ": Bearish impulse with volume confirmation";
   
   CSVUtils::Log(LOG_LEVEL_DEBUG, __FUNCTION__, m_strategyName + " generated SHORT signal");
   return true;
}

//+------------------------------------------------------------------+
//| Check for exit signal                                            |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::CheckExitSignal(ulong positionTicket, string &exitReason)
{
   if(!PositionSelectByTicket(positionTicket)) {
      return false;
   }
   
   // Get position data
   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   string posComment = PositionGetString(POSITION_COMMENT);
   double posProfit = PositionGetDouble(POSITION_PROFIT);
   double posVolume = PositionGetDouble(POSITION_VOLUME);
   double posOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   
   // Only manage positions from this strategy
   if(StringFind(posComment, m_strategyID) < 0) {
      return false;
   }
   
   // Check for momentum reversal
   if(posType == POSITION_TYPE_BUY && DetectBearishImpulse()) {
      exitReason = "Momentum reversal to bearish";
      return true;
   } else if(posType == POSITION_TYPE_SELL && DetectBullishImpulse()) {
      exitReason = "Momentum reversal to bullish";
      return true;
   }
   
   // Check EMA crossover for trend change
   double emaFast = m_analyzer.GetEMA(PERIOD_M5, m_emaPeriodFast, 0);
   double emaSlow = m_analyzer.GetEMA(PERIOD_M5, m_emaPeriodSlow, 0);
   double emaPrevFast = m_analyzer.GetEMA(PERIOD_M5, m_emaPeriodFast, 1);
   double emaPrevSlow = m_analyzer.GetEMA(PERIOD_M5, m_emaPeriodSlow, 1);
   
   if(posType == POSITION_TYPE_BUY && 
      emaPrevFast > emaPrevSlow && emaFast < emaSlow) {
      // Bearish EMA crossover
      exitReason = "EMA crossover bearish";
      return true;
   } else if(posType == POSITION_TYPE_SELL && 
             emaPrevFast < emaPrevSlow && emaFast > emaSlow) {
      // Bullish EMA crossover
      exitReason = "EMA crossover bullish";
      return true;
   }
   
   // Time-based exit (exit after 15 bars - medium-term scalping)
   datetime posOpenTime = (datetime)PositionGetInteger(POSITION_TIME);
   datetime currentTime = TimeCurrent();
   int barsSinceOpen = 0;
   
   // Count bars since position opening
   datetime barTimes[];
   ArraySetAsSeries(barTimes, true);
   int copied = CopyTime(Symbol(), PERIOD_M5, 0, 50, barTimes);
   
   if(copied > 0) {
      for(int i = 0; i < copied; i++) {
         if(barTimes[i] <= posOpenTime) {
            barsSinceOpen = i;
            break;
         }
      }
   }
   
   if(barsSinceOpen >= 15) {
      exitReason = "Time-based exit (15 bars passed)";
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Detect bullish impulse                                           |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::DetectBullishImpulse()
{
   // Check last 3 candles for bullish impulse
   double close[], open[], high[], low[];
   ArraySetAsSeries(close, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   
   int copied = CopyClose(Symbol(), PERIOD_M5, 0, 3, close);
   if(copied != 3) return false;
   
   copied = CopyOpen(Symbol(), PERIOD_M5, 0, 3, open);
   if(copied != 3) return false;
   
   copied = CopyHigh(Symbol(), PERIOD_M5, 0, 3, high);
   if(copied != 3) return false;
   
   copied = CopyLow(Symbol(), PERIOD_M5, 0, 3, low);
   if(copied != 3) return false;
   
   // Check for strong bullish candle
   bool strongBullish = (close[0] > open[0]) && 
                         ((close[0] - open[0]) > (high[0] - low[0]) * 0.6);
   
   // Check previous candles for consolidation or build-up
   bool priorConsolidation = MathAbs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 &&
                            MathAbs(close[2] - open[2]) < (high[2] - low[2]) * 0.3;
   
   // Price breaking above recent high
   bool breakingHigh = close[0] > MathMax(high[1], high[2]);
   
   return (strongBullish && (priorConsolidation || breakingHigh));
}

//+------------------------------------------------------------------+
//| Detect bearish impulse                                           |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::DetectBearishImpulse()
{
   // Check last 3 candles for bearish impulse
   double close[], open[], high[], low[];
   ArraySetAsSeries(close, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   
   int copied = CopyClose(Symbol(), PERIOD_M5, 0, 3, close);
   if(copied != 3) return false;
   
   copied = CopyOpen(Symbol(), PERIOD_M5, 0, 3, open);
   if(copied != 3) return false;
   
   copied = CopyHigh(Symbol(), PERIOD_M5, 0, 3, high);
   if(copied != 3) return false;
   
   copied = CopyLow(Symbol(), PERIOD_M5, 0, 3, low);
   if(copied != 3) return false;
   
   // Check for strong bearish candle
   bool strongBearish = (close[0] < open[0]) && 
                         ((open[0] - close[0]) > (high[0] - low[0]) * 0.6);
   
   // Check previous candles for consolidation or build-up
   bool priorConsolidation = MathAbs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 &&
                            MathAbs(close[2] - open[2]) < (high[2] - low[2]) * 0.3;
   
   // Price breaking below recent low
   bool breakingLow = close[0] < MathMin(low[1], low[2]);
   
   return (strongBearish && (priorConsolidation || breakingLow));
}

//+------------------------------------------------------------------+
//| Check if momentum is strong in specified direction                |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::IsMomentumStrong(bool bullish)
{
   // Calculate momentum using price change over recent periods
   double close[];
   ArraySetAsSeries(close, true);
   
   int copied = CopyClose(Symbol(), PERIOD_M5, 0, m_momentumPeriod + 1, close);
   if(copied != m_momentumPeriod + 1) return false;
   
   // Calculate percentage price change
   double priceChange = (close[0] - close[m_momentumPeriod]) / close[m_momentumPeriod] * 100.0;
   
   if(bullish) {
      return priceChange > m_momentumThreshold;
   } else {
      return priceChange < -m_momentumThreshold;
   }
}

//+------------------------------------------------------------------+
//| Check if volume is spiking                                       |
//+------------------------------------------------------------------+
bool CSVImpulseRiderScalper::IsVolumeSpiking()
{
   // Get current volume and average volume
   double currentVolume = m_analyzer.GetTickVolume(PERIOD_M5, 0);
   double avgVolume = m_analyzer.GetAverageTickVolume(PERIOD_M5);
   
   // Check if current volume is above threshold
   return (currentVolume > avgVolume * m_volumeSpikeThreshold);
}
