//+------------------------------------------------------------------+
//|                                                      SVCore.mqh   |
//+------------------------------------------------------------------+
#property copyright "ScalpingVortex"
#property link      "https://github.com/H3NST7/ScalpingVortex"
#property version   "1.00"
#property strict

// Include core system components
#include "SVUtils.mqh"
#include "SVPortfolio.mqh"
#include "SVTradeManager.mqh"
#include "SVMarketAnalyzer.mqh"
#include "SVDashboard.mqh"
//+------------------------------------------------------------------+
//| Core class for the ScalpingVortex EA system                      |
//+------------------------------------------------------------------+
class CSVCore
{
private:
   // System components
   CSVPortfolio*      m_portfolio;
   CSVTradeManager*   m_tradeManager;
   CSVMarketAnalyzer* m_marketAnalyzer;
   
   // System state
   bool              m_isInitialized;
   bool              m_isEnabled;
   bool              m_isBacktesting;
   
   // Configuration
   int               m_magicNumber;
   int               m_slippage;
   double            m_defaultRiskPerTrade;
   string            m_symbol;
   ENUM_TIMEFRAMES   m_timeframe;
   
   // Operational parameters
   int               m_maxConcurrentTrades;
   bool              m_allowLongs;
   bool              m_allowShorts;
   double            m_minVolatility;
   
   // Performance tracking
   datetime          m_startTime;
   datetime          m_lastUpdateTime;
   int               m_totalSignalsGenerated;
   int               m_validSignalsCount;
   int               m_profitableSignalsCount;
   
public:
                     CSVCore();
                     ~CSVCore();
   
   // Core methods
   bool              Initialize(int magicNumber, int slippage, double riskPerTrade, string symbol = NULL, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT);
   void              Cleanup();
   bool              ProcessTick();
   bool              ProcessTimer();
   
   // System configuration
   void              EnableTrading() { m_isEnabled = true; }
   void              DisableTrading() { m_isEnabled = false; }
   bool              IsInitialized() const { return m_isInitialized; }
   bool              IsEnabled() const { return m_isEnabled; }
   
   void              SetMaxConcurrentTrades(int max) { m_maxConcurrentTrades = max; }
   int               GetMaxConcurrentTrades() const { return m_maxConcurrentTrades; }
   
   void              SetDirectionalBias(bool allowLongs, bool allowShorts) { m_allowLongs = allowLongs; m_allowShorts = allowShorts; }
   void              SetMinimumVolatility(double atrThreshold) { m_minVolatility = atrThreshold; }
   
   // Component access
   CSVPortfolio*     GetPortfolio() { return m_portfolio; }
   CSVTradeManager*  GetTradeManager() { return m_tradeManager; }
   CSVMarketAnalyzer* GetMarketAnalyzer() { return m_marketAnalyzer; }
   
   // System metrics
   int               GetSignalCount() const { return m_totalSignalsGenerated; }
   double            GetSignalQuality() const;
   double            GetSystemPerformance() const;
   
private:
   // Internal processing methods
   bool              InitializeComponents();
   bool              CheckTradingConditions();
   bool              GenerateSignals(int &signalType, double &entryPrice, double &stopLoss, double &takeProfit);
   bool              ExecuteSignal(int signalType, double entryPrice, double stopLoss, double takeProfit);
   bool              UpdateSystem();
   
   // Position sizing and risk management
   double            CalculatePositionSize(double stopLossPrice);
};

//+------------------------------------------------------------------+
//| Constructor                                                      |
//+------------------------------------------------------------------+
CSVCore::CSVCore()
{
   // Initialize pointers
   m_portfolio = NULL;
   m_tradeManager = NULL;
   m_marketAnalyzer = NULL;
   
   // Default state
   m_isInitialized = false;
   m_isEnabled = false;
   m_isBacktesting = IsBacktesting();
   
   // Default configuration
   m_magicNumber = 12345;
   m_slippage = 3;
   m_defaultRiskPerTrade = 1.0; // 1% risk per trade
   m_symbol = Symbol();
   m_timeframe = Period();
   
   // Default operational parameters
   m_maxConcurrentTrades = 5;
   m_allowLongs = true;
   m_allowShorts = true;
   m_minVolatility = 0.0;
   
   // Performance tracking
   m_startTime = 0;
   m_lastUpdateTime = 0;
   m_totalSignalsGenerated = 0;
   m_validSignalsCount = 0;
   m_profitableSignalsCount = 0;
}

//+------------------------------------------------------------------+
//| Destructor                                                       |
//+------------------------------------------------------------------+
CSVCore::~CSVCore()
{
   Cleanup();
}

//+------------------------------------------------------------------+
//| Initialize the system                                            |
//+------------------------------------------------------------------+
bool CSVCore::Initialize(int magicNumber, int slippage, double riskPerTrade, string symbol = NULL, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT)
{
   // Clean up previous resources if any
   Cleanup();
   
   // Set configuration
   m_magicNumber = magicNumber;
   m_slippage = slippage;
   m_defaultRiskPerTrade = riskPerTrade;
   
   m_symbol = (symbol == NULL || symbol == "") ? Symbol() : symbol;
   m_timeframe = (timeframe == PERIOD_CURRENT) ? Period() : timeframe;
   
   // Initialize system components
   if(!InitializeComponents())
   {
      Print("Failed to initialize system components");
      Cleanup();
      return false;
   }
   
   // Set state
   m_isInitialized = true;
   m_isEnabled = true;
   
   // Set timestamps
   m_startTime = TimeCurrent();
   m_lastUpdateTime = m_startTime;
   
   Print("ScalpingVortex Core initialized. Magic: ", m_magicNumber, ", Symbol: ", m_symbol, ", Timeframe: ", EnumToString(m_timeframe));
   
   return true;
}

//+------------------------------------------------------------------+
//| Initialize all system components                                 |
//+------------------------------------------------------------------+
bool CSVCore::InitializeComponents()
{
   // Create portfolio component
   m_portfolio = new CSVPortfolio();
   
   if(m_portfolio == NULL)
   {
      Print("Failed to create portfolio component");
      return false;
   }
   
   if(!m_portfolio.Initialize())
   {
      Print("Failed to initialize portfolio component");
      return false;
   }
   
   // Create trade manager component
   m_tradeManager = new CSVTradeManager();
   
   if(m_tradeManager == NULL)
   {
      Print("Failed to create trade manager component");
      return false;
   }
   
   if(!m_tradeManager.Initialize(m_portfolio, m_magicNumber, m_slippage))
   {
      Print("Failed to initialize trade manager component");
      return false;
   }
   
   // Configure trade manager
   m_tradeManager.SetRiskPerTrade(m_defaultRiskPerTrade);
   m_tradeManager.SetMaxOpenPositions(m_maxConcurrentTrades);
   
   // Create market analyzer component
   m_marketAnalyzer = new CSVMarketAnalyzer();
   
   if(m_marketAnalyzer == NULL)
   {
      Print("Failed to create market analyzer component");
      return false;
   }
   
   // Initialize market analyzer with default parameters
   if(!m_marketAnalyzer.Initialize(20, 50, 14, 14, 20, 2.0, 10))
   {
      Print("Failed to initialize market analyzer component");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Clean up resources                                               |
//+------------------------------------------------------------------+
void CSVCore::Cleanup()
{
   // Clean up the market analyzer
   if(m_marketAnalyzer != NULL)
   {
      delete m_marketAnalyzer;
      m_marketAnalyzer = NULL;
   }
   
   // Clean up the trade manager
   if(m_tradeManager != NULL)
   {
      delete m_tradeManager;
      m_tradeManager = NULL;
   }
   
   // Clean up the portfolio
   if(m_portfolio != NULL)
   {
      delete m_portfolio;
      m_portfolio = NULL;
   }
   
   m_isInitialized = false;
   m_isEnabled = false;
}

//+------------------------------------------------------------------+
//| Process tick event - main EA execution point                     |
//+------------------------------------------------------------------+
bool CSVCore::ProcessTick()
{
   if(!m_isInitialized || !m_isEnabled)
      return false;
      
   // Update system components
   if(!UpdateSystem())
      return false;
      
   // Check if trading conditions are met
   if(!CheckTradingConditions())
      return false;
      
   // Generate signals
   int signalType = 0;
   double entryPrice = 0.0;
   double stopLoss = 0.0;
   double takeProfit = 0.0;
   
   if(GenerateSignals(signalType, entryPrice, stopLoss, takeProfit))
   {
      // Execute signal
      ExecuteSignal(signalType, entryPrice, stopLoss, takeProfit);
   }
   
   m_lastUpdateTime = TimeCurrent();
   
   return true;
}

//+------------------------------------------------------------------+
//| Process timer event - periodic tasks                             |
//+------------------------------------------------------------------+
bool CSVCore::ProcessTimer()
{
   if(!m_isInitialized || !m_isEnabled)
      return false;
      
   // Update system state
   UpdateSystem();
   
   // Perform periodic tasks
   // - Update trade statistics
   if(m_portfolio != NULL)
      m_portfolio.UpdateTradeStatistics();
      
   // - Check for trade management (trailing stops, partial closes, etc.)
   
   m_lastUpdateTime = TimeCurrent();
   
   return true;
}

//+------------------------------------------------------------------+
//| Update system components                                         |
//+------------------------------------------------------------------+
bool CSVCore::UpdateSystem()
{
   // Update portfolio
   if(m_portfolio != NULL)
   {
      if(!m_portfolio.Update())
      {
         Print("Failed to update portfolio");
         return false;
      }
   }
   else
      return false;
      
   // Update trade manager
   if(m_tradeManager != NULL)
   {
      if(!m_tradeManager.Update())
      {
         Print("Failed to update trade manager");
         return false;
      }
   }
   else
      return false;
      
   // Update market analyzer
   if(m_marketAnalyzer != NULL)
   {
      if(!m_marketAnalyzer.Update(m_symbol, m_timeframe))
      {
         Print("Failed to update market analyzer");
         return false;
      }
   }
   else
      return false;
      
   return true;
}

//+------------------------------------------------------------------+
//| Check if trading conditions are met                              |
//+------------------------------------------------------------------+
bool CSVCore::CheckTradingConditions()
{
   // Check if market is open
   if(!IsMarketOpen(m_symbol))
   {
      //Print("Market is closed for ", m_symbol);
      return false;
   }
   
   // Check if we're within trading hours
   if(!IsTradingHour())
   {
      //Print("Outside of trading hours");
      return false;
   }
   
   // Check for maximum concurrent trades
   int openPositions = m_portfolio.CountOpenPositions();
   if(openPositions >= m_maxConcurrentTrades)
   {
      //Print("Maximum concurrent trades reached: ", m_maxConcurrentTrades);
      return false;
   }
   
   // Check minimum volatility
   double atr = m_marketAnalyzer.GetAverageTrueRange(m_symbol, m_timeframe);
   if(atr < m_minVolatility)
   {
      //Print("Volatility too low: ", atr, " < ", m_minVolatility);
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Generate trading signals                                         |
//+------------------------------------------------------------------+
bool CSVCore::GenerateSignals(int &signalType, double &entryPrice, double &stopLoss, double &takeProfit)
{
   // Reset signal type
   signalType = 0; // 0 = no signal, 1 = buy, -1 = sell
   
   // Get current market data
   double bid = MarketInfo(m_symbol, MODE_BID);
   double ask = MarketInfo(m_symbol, MODE_ASK);
   double point = MarketInfo(m_symbol, MODE_POINT);
   int digits = (int)MarketInfo(m_symbol, MODE_DIGITS);
   
   // Get ATR for stop loss and take profit calculation
   double atr = m_marketAnalyzer.GetAverageTrueRange(m_symbol, m_timeframe);
   
   // Default stop loss and take profit distances (2 ATR, 3 ATR)
   double slDistance = atr * 2.0;
   double tpDistance = atr * 3.0;
   
   // Check for buy signal
   if(m_allowLongs && m_marketAnalyzer.IsTrendUp(m_symbol, m_timeframe))
   {
      // Additional conditions for buy entry
      if(m_marketAnalyzer.GetRSI(m_symbol, m_timeframe) < 70.0 &&
         m_marketAnalyzer.IsVolumeIncreasing(m_symbol, m_timeframe))
      {
         signalType = 1; // Buy signal
         entryPrice = ask;
         stopLoss = NormalizeDouble(entryPrice - slDistance, digits);
         takeProfit = NormalizeDouble(entryPrice + tpDistance, digits);
         
         m_totalSignalsGenerated++;
         return true;
      }
   }
   
   // Check for sell signal
   if(m_allowShorts && m_marketAnalyzer.IsTrendDown(m_symbol, m_timeframe))
   {
      // Additional conditions for sell entry
      if(m_marketAnalyzer.GetRSI(m_symbol, m_timeframe) > 30.0 &&
         m_marketAnalyzer.IsVolumeIncreasing(m_symbol, m_timeframe))
      {
         signalType = -1; // Sell signal
         entryPrice = bid;
         stopLoss = NormalizeDouble(entryPrice + slDistance, digits);
         takeProfit = NormalizeDouble(entryPrice - tpDistance, digits);
         
         m_totalSignalsGenerated++;
         return true;
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Execute a trading signal                                         |
//+------------------------------------------------------------------+
bool CSVCore::ExecuteSignal(int signalType, double entryPrice, double stopLoss, double takeProfit)
{
   if(signalType == 0 || m_tradeManager == NULL)
      return false;
      
   // Calculate position size based on risk
   double lotSize = CalculatePositionSize(stopLoss);
   
   if(lotSize <= 0.0)
   {
      Print("Invalid lot size calculated: ", lotSize);
      return false;
   }
   
   bool result = false;
   
   // Execute the trade
   if(signalType > 0)
   {
      // Buy trade
      result = m_tradeManager.OpenBuyOrder(m_symbol, lotSize, stopLoss, takeProfit);
      
      if(result)
      {
         Print("Buy order executed. Lots: ", lotSize, ", Entry: ", entryPrice, ", SL: ", stopLoss, ", TP: ", takeProfit);
         m_validSignalsCount++;
      }
   }
   else if(signalType < 0)
   {
      // Sell trade
      result = m_tradeManager.OpenSellOrder(m_symbol, lotSize, stopLoss, takeProfit);
      
      if(result)
      {
         Print("Sell order executed. Lots: ", lotSize, ", Entry: ", entryPrice, ", SL: ", stopLoss, ", TP: ", takeProfit);
         m_validSignalsCount++;
      }
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| Calculate position size based on risk and stop loss              |
//+------------------------------------------------------------------+
double CSVCore::CalculatePositionSize(double stopLossPrice)
{
   if(m_portfolio == NULL || stopLossPrice == 0.0)
      return 0.0;
      
   double entryPrice = (stopLossPrice > MarketInfo(m_symbol, MODE_ASK)) ? 
                        MarketInfo(m_symbol, MODE_BID) : // Sell order
                        MarketInfo(m_symbol, MODE_ASK);  // Buy order
   
   double stopLossPoints = MathAbs(entryPrice - stopLossPrice) / MarketInfo(m_symbol, MODE_POINT);
   
   // Calculate lot size based on risk percentage and stop loss points
   return m_portfolio.CalculateLotSizeFromRisk(m_symbol, m_defaultRiskPerTrade, stopLossPoints);
}

//+------------------------------------------------------------------+
//| Get signal quality metric                                        |
//+------------------------------------------------------------------+
double CSVCore::GetSignalQuality() const
{
   if(m_totalSignalsGenerated == 0)
      return 0.0;
      
   // Signal quality = valid signals / total signals
   return (double)m_validSignalsCount / m_totalSignalsGenerated * 100.0;
}

//+------------------------------------------------------------------+
//| Get system performance metric                                    |
//+------------------------------------------------------------------+
double CSVCore::GetSystemPerformance() const
{
   if(m_validSignalsCount == 0)
      return 0.0;
      
   // Performance = profitable signals / valid signals
   return (double)m_profitableSignalsCount / m_validSignalsCount * 100.0;
}
