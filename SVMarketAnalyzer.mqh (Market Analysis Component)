//+------------------------------------------------------------------+
//|                                           SVMarketAnalyzer.mqh    |
//+------------------------------------------------------------------+
#property copyright "ScalpingVortex"
#property link      "https://github.com/H3NST7/ScalpingVortex"
#property version   "1.00"
#property strict

// Include files
#include "SVUtils.mqh"

//+------------------------------------------------------------------+
//| Market analysis class for technical indicators and volume         |
//+------------------------------------------------------------------+
class CSVMarketAnalyzer
{
private:
   // Indicator buffer arrays
   double            m_maFast[];       // Fast moving average values
   double            m_maSlow[];       // Slow moving average values
   double            m_atr[];          // Average True Range values
   double            m_rsi[];          // RSI values
   double            m_bollingerUpper[]; // Bollinger upper band
   double            m_bollingerMiddle[]; // Bollinger middle band
   double            m_bollingerLower[]; // Bollinger lower band
   
   // Indicator handles
   int               m_maFastHandle;
   int               m_maSlowHandle;
   int               m_atrHandle;
   int               m_rsiHandle;
   int               m_bollingerHandle;
   
   // Indicator settings
   int               m_maFastPeriod;
   int               m_maSlowPeriod;
   int               m_atrPeriod;
   int               m_rsiPeriod;
   int               m_bollingerPeriod;
   double            m_bollingerDeviation;
   
   // State tracking
   bool              m_isInitialized;
   datetime          m_lastUpdateTime;
   
   // Volume analysis
   long              m_volumeBuffer[];
   double            m_volumeMA[];
   int               m_volumeWindow;
   
public:
                     CSVMarketAnalyzer();
                     ~CSVMarketAnalyzer();
   
   // Initialization and update methods
   bool              Initialize(int maFastPeriod, int maSlowPeriod, int atrPeriod, int rsiPeriod, 
                              int bollingerPeriod, double bollingerDeviation, int volumeWindow);
   bool              Update(string symbol, ENUM_TIMEFRAMES timeframe);
   
   // Trend analysis methods
   bool              IsTrendUp(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsTrendDown(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsTrendChanging(string symbol, ENUM_TIMEFRAMES timeframe);
   double            GetTrendStrength(string symbol, ENUM_TIMEFRAMES timeframe);
   
   // Volatility and momentum methods
   double            GetAverageTrueRange(string symbol, ENUM_TIMEFRAMES timeframe);
   double            GetRSI(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsOverbought(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsOversold(string symbol, ENUM_TIMEFRAMES timeframe);
   
   // Price pattern methods
   bool              IsBollingerSqueeze(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsBollingerBreakoutUp(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsBollingerBreakoutDown(string symbol, ENUM_TIMEFRAMES timeframe);
   
   // Volume analysis methods
   bool              AnalyzeVolume(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsVolumeIncreasing(string symbol, ENUM_TIMEFRAMES timeframe);
   bool              IsVolumeHigherThanAverage(string symbol, ENUM_TIMEFRAMES timeframe, double factor = 1.2);
   double            GetVolumeStrength(string symbol, ENUM_TIMEFRAMES timeframe);
   
private:
   // Helper methods
   bool              UpdateIndicators(string symbol, ENUM_TIMEFRAMES timeframe);
   double            CalculateVolumeMA();
};

//+------------------------------------------------------------------+
//| Constructor                                                      |
//+------------------------------------------------------------------+
CSVMarketAnalyzer::CSVMarketAnalyzer()
{
   // Default indicator settings
   m_maFastPeriod = 20;
   m_maSlowPeriod = 50;
   m_atrPeriod = 14;
   m_rsiPeriod = 14;
   m_bollingerPeriod = 20;
   m_bollingerDeviation = 2.0;
   m_volumeWindow = 10;
   
   // Initialize state variables
   m_isInitialized = false;
   m_lastUpdateTime = 0;
   
   // Set handles to invalid state
   m_maFastHandle = INVALID_HANDLE;
   m_maSlowHandle = INVALID_HANDLE;
   m_atrHandle = INVALID_HANDLE;
   m_rsiHandle = INVALID_HANDLE;
   m_bollingerHandle = INVALID_HANDLE;
}

//+------------------------------------------------------------------+
//| Destructor                                                       |
//+------------------------------------------------------------------+
CSVMarketAnalyzer::~CSVMarketAnalyzer()
{
   // Clean up indicator handles and arrays
   ArrayFree(m_maFast);
   ArrayFree(m_maSlow);
   ArrayFree(m_atr);
   ArrayFree(m_rsi);
   ArrayFree(m_bollingerUpper);
   ArrayFree(m_bollingerMiddle);
   ArrayFree(m_bollingerLower);
   ArrayFree(m_volumeBuffer);
   ArrayFree(m_volumeMA);
}

//+------------------------------------------------------------------+
//| Initialize the market analyzer                                   |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::Initialize(int maFastPeriod, int maSlowPeriod, int atrPeriod, int rsiPeriod, 
                                int bollingerPeriod, double bollingerDeviation, int volumeWindow)
{
   // Set indicator parameters
   m_maFastPeriod = maFastPeriod;
   m_maSlowPeriod = maSlowPeriod;
   m_atrPeriod = atrPeriod;
   m_rsiPeriod = rsiPeriod;
   m_bollingerPeriod = bollingerPeriod;
   m_bollingerDeviation = bollingerDeviation;
   m_volumeWindow = volumeWindow;
   
   // Allocate arrays with buffer sizes
   int bufferSize = MathMax(m_maFastPeriod, MathMax(m_maSlowPeriod, MathMax(m_atrPeriod, MathMax(m_rsiPeriod, m_bollingerPeriod)))) * 2;
   
   ArrayResize(m_maFast, bufferSize);
   ArrayResize(m_maSlow, bufferSize);
   ArrayResize(m_atr, bufferSize);
   ArrayResize(m_rsi, bufferSize);
   ArrayResize(m_bollingerUpper, bufferSize);
   ArrayResize(m_bollingerMiddle, bufferSize);
   ArrayResize(m_bollingerLower, bufferSize);
   
   // Allocate volume analysis arrays
   ArrayResize(m_volumeBuffer, m_volumeWindow * 2);
   ArrayResize(m_volumeMA, m_volumeWindow);
   
   // Set initialization flag
   m_isInitialized = true;
   m_lastUpdateTime = TimeCurrent();
   
   return true;
}

//+------------------------------------------------------------------+
//| Update all analysis data                                         |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::Update(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   // Update indicators
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Update volume data
   if(!AnalyzeVolume(symbol, timeframe))
      return false;
      
   // Update timestamp
   m_lastUpdateTime = TimeCurrent();
   
   return true;
}

//+------------------------------------------------------------------+
//| Update all technical indicators                                  |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::UpdateIndicators(string symbol, ENUM_TIMEFRAMES timeframe)
{
   // Calculate Moving Averages
   int copied = CopyBuffer(iMA(symbol, timeframe, m_maFastPeriod, 0, MODE_SMA, PRICE_CLOSE), 0, 0, m_maFastPeriod, m_maFast);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy fast MA data: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   copied = CopyBuffer(iMA(symbol, timeframe, m_maSlowPeriod, 0, MODE_SMA, PRICE_CLOSE), 0, 0, m_maSlowPeriod, m_maSlow);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy slow MA data: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Calculate ATR
   copied = CopyBuffer(iATR(symbol, timeframe, m_atrPeriod), 0, 0, m_atrPeriod, m_atr);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy ATR data: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Calculate RSI
   copied = CopyBuffer(iRSI(symbol, timeframe, m_rsiPeriod, PRICE_CLOSE), 0, 0, m_rsiPeriod, m_rsi);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy RSI data: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Calculate Bollinger Bands
   int bandsHandle = iBands(symbol, timeframe, m_bollingerPeriod, m_bollingerDeviation, 0, PRICE_CLOSE);
   
   // Upper band (0)
   copied = CopyBuffer(bandsHandle, 0, 0, m_bollingerPeriod, m_bollingerUpper);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy Bollinger upper band: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Middle band (1)
   copied = CopyBuffer(bandsHandle, 1, 0, m_bollingerPeriod, m_bollingerMiddle);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy Bollinger middle band: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Lower band (2)
   copied = CopyBuffer(bandsHandle, 2, 0, m_bollingerPeriod, m_bollingerLower);
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy Bollinger lower band: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Check if trend is up                                             |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsTrendUp(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Check if fast MA is above slow MA
   return m_maFast[0] > m_maSlow[0];
}

//+------------------------------------------------------------------+
//| Check if trend is down                                           |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsTrendDown(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Check if fast MA is below slow MA
   return m_maFast[0] < m_maSlow[0];
}

//+------------------------------------------------------------------+
//| Check if trend is changing direction                             |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsTrendChanging(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Check for crossover
   return (m_maFast[1] <= m_maSlow[1] && m_maFast[0] > m_maSlow[0]) || // Bullish crossover
          (m_maFast[1] >= m_maSlow[1] && m_maFast[0] < m_maSlow[0]);   // Bearish crossover
}

//+------------------------------------------------------------------+
//| Calculate trend strength (percentage difference between MAs)     |
//+------------------------------------------------------------------+
double CSVMarketAnalyzer::GetTrendStrength(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return 0.0;
      
   if(!UpdateIndicators(symbol, timeframe))
      return 0.0;
      
   // Calculate percentage difference between fast and slow MAs
   if(m_maSlow[0] == 0)
      return 0.0;
      
   return MathAbs((m_maFast[0] - m_maSlow[0]) / m_maSlow[0] * 100.0);
}

//+------------------------------------------------------------------+
//| Get Average True Range value                                     |
//+------------------------------------------------------------------+
double CSVMarketAnalyzer::GetAverageTrueRange(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return 0.0;
      
   if(!UpdateIndicators(symbol, timeframe))
      return 0.0;
      
   return m_atr[0];
}

//+------------------------------------------------------------------+
//| Get RSI value                                                    |
//+------------------------------------------------------------------+
double CSVMarketAnalyzer::GetRSI(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return 0.0;
      
   if(!UpdateIndicators(symbol, timeframe))
      return 0.0;
      
   return m_rsi[0];
}

//+------------------------------------------------------------------+
//| Check if market is overbought (RSI > 70)                         |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsOverbought(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   return m_rsi[0] > 70.0;
}

//+------------------------------------------------------------------+
//| Check if market is oversold (RSI < 30)                           |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsOversold(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   return m_rsi[0] < 30.0;
}

//+------------------------------------------------------------------+
//| Check for Bollinger Bands squeeze (volatility contraction)       |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsBollingerSqueeze(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Calculate the band width as percentage of price
   double bandWidth = (m_bollingerUpper[0] - m_bollingerLower[0]) / m_bollingerMiddle[0] * 100.0;
   double prevBandWidth = (m_bollingerUpper[1] - m_bollingerLower[1]) / m_bollingerMiddle[1] * 100.0;
   
   // A squeeze is occurring when the band width is narrowing
   return bandWidth < prevBandWidth && bandWidth < 3.0; // 3% threshold can be adjusted
}

//+------------------------------------------------------------------+
//| Check for upward Bollinger Bands breakout                        |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsBollingerBreakoutUp(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Get current price
   double close[];
   if(CopyClose(symbol, timeframe, 0, 2, close) <= 0)
      return false;
      
   // Check for breakout: previous close within bands, current close above upper band
   return close[1] < m_bollingerUpper[1] && close[0] > m_bollingerUpper[0];
}

//+------------------------------------------------------------------+
//| Check for downward Bollinger Bands breakout                      |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsBollingerBreakoutDown(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   if(!UpdateIndicators(symbol, timeframe))
      return false;
      
   // Get current price
   double close[];
   if(CopyClose(symbol, timeframe, 0, 2, close) <= 0)
      return false;
      
   // Check for breakout: previous close within bands, current close below lower band
   return close[1] > m_bollingerLower[1] && close[0] < m_bollingerLower[0];
}

//+------------------------------------------------------------------+
//| Analyze volume                                                   |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::AnalyzeVolume(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!m_isInitialized)
      return false;
      
   // Get tick volumes
   ArraySetAsSeries(m_volumeBuffer, true);
   
   // Fixed CopyTickVolume call with proper parameter types
   int copied = CopyTickVolume(symbol, timeframe, 0, m_volumeWindow * 2, m_volumeBuffer);
   
   if(copied <= 0)
   {
      int errorCode = GetLastError();
      Print("Failed to copy volume data: ", errorCode, " - ", GetErrorDescription(errorCode));
      return false;
   }
   
   // Calculate volume moving average
   CalculateVolumeMA();
   
   return true;
}

//+------------------------------------------------------------------+
//| Calculate volume moving average                                  |
//+------------------------------------------------------------------+
double CSVMarketAnalyzer::CalculateVolumeMA()
{
   double sum = 0;
   
   for(int i = 0; i < m_volumeWindow; i++)
   {
      sum += m_volumeBuffer[i];
      m_volumeMA[i] = sum / (i + 1); // Calculate running average
   }
   
   return m_volumeMA[m_volumeWindow - 1]; // Return the last MA value
}

//+------------------------------------------------------------------+
//| Check if volume is increasing                                    |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsVolumeIncreasing(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!AnalyzeVolume(symbol, timeframe))
      return false;
      
   // Check if current volume is increasing over the last few bars
   return m_volumeBuffer[0] > m_volumeBuffer[1] && m_volumeBuffer[1] > m_volumeBuffer[2];
}

//+------------------------------------------------------------------+
//| Check if volume is higher than average by a factor               |
//+------------------------------------------------------------------+
bool CSVMarketAnalyzer::IsVolumeHigherThanAverage(string symbol, ENUM_TIMEFRAMES timeframe, double factor = 1.2)
{
   if(!AnalyzeVolume(symbol, timeframe))
      return false;
      
   // Current volume
   long currentVolume = m_volumeBuffer[0];
   
   // Average volume (last value in the MA array)
   double averageVolume = m_volumeMA[m_volumeWindow - 1];
   
   return currentVolume > averageVolume * factor;
}

//+------------------------------------------------------------------+
//| Calculate volume strength (percentage above average)             |
//+------------------------------------------------------------------+
double CSVMarketAnalyzer::GetVolumeStrength(string symbol, ENUM_TIMEFRAMES timeframe)
{
   if(!AnalyzeVolume(symbol, timeframe))
      return 0.0;
      
   // Current volume
   double currentVolume = (double)m_volumeBuffer[0];
   
   // Average volume (last value in the MA array)
   double averageVolume = m_volumeMA[m_volumeWindow - 1];
   
   if(averageVolume == 0)
      return 0.0;
      
   return (currentVolume - averageVolume) / averageVolume * 100.0;
}
